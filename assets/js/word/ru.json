{
  "menu_home": "Главная",
  "menu_engine": "Движок",
  "menu_utils": "Утилиты",
  "menu_forms": "Формы",
  "menu_word": "Языки",
  "menu_components": "Компоненты",
  "menu_routes": "Маршрутизация",
  "page_404_content": "<h1>404</h1><p>Такой страницы не существует</p>",
  "home_info_content": "<p>\n  Javascript клиентский фреймворк от компании forweb.org включает в себя несколько модулей для создания интерактивных веб приложений. Скачать его можно тут - <a href=\"https://github.com/forweb/core\">https://github.com/forweb/core</a>.\nЧто же в нем такого особенного?\n  </p>\n  <ul>\n  <li>\n  Модульность. Единственный объект глобальной видимости - Engine.\n  </li>\n  <li>\n  Модульность. Каждый класс находится в отдельном файле, может иметь ряд зависимостей, и не будет инициализирован до инициализации всех зависимостей.\n  </li>\n  <li>\n  Модульность. Приложение может быть (а может и не быть) разделено на множество отдельный js файлов, что позволяет разбить тяжелые приложения (размером 10мб, например) на несколько легковесных файлов, которые будут динамически подгружены по мере необходимости.\n  </li>\n  <li>\n  Принципы ООП программирования\n  </li>\n  <li>\n  Легко интегрируется с другими технологиями и фреймворками, такими как npm, jquery, prototypejs и проч. (предположительно, легко интегрируется с любыми технологиями)\n  </li>\n  <li>\n  Имеет базовый набор компонент, таких как элементы форм, панель вкладок, модальные окна, гриды\n  </li>\n  <li>\n  Имеет модуль интернационализации</li>\n  <li>\n  Имеет AJAX и AJAX-Rest модули для работы с AJAX запросами основанные на Promise\n  </li>\n  <li>\n  Имеет модуль маршрутизации\n  </li>\n<li>Спроектирован для single-page приложений</li>  </ul>\n  <p>\n  Модульность, компоненты, ajax, маршрутизация, ООП, интернационализация, 28кб. Почему бы и не <a href=\"/utils/dom\">начать</a>?\n  </p>",
  "engine_info_content": "<p>Engine - ключевой объект фреймворка, и единственный объект глобальной видимости. Он ответственен за динамическую подгрузку скриптов и разрешение зависимостей. Так вышло, что помимо своих функций, объект способен отображать пользовательские уведомления.\n</p>\n  <p>\n  Для того чтобы загружать модули, движок должен иметь посредника, который будет находить путь к скрипту согласно имени класса. Для этого используется поле pathBuilder, которое может быть null, массивом либо функцией. Если это функция, то она будет принимать один аргумент - имя класса, и возвращать путь к скрипту. Если это массив, то это должен быть массив объектов, каждый из которых имеет функцию buildPath, которая также принимает имя класса. В случае с массивом, первым пытаться построить путь к скрипту будет последний добавленный объект. Если объект возвращает пустую строку, то следующий объект будет пытаться построить путь. Если ни один объект не может построить путь, то будет выброшено исключение.\n</p>\n  <code id=\"sample_path_builder\">\nEngine.pathBuilder = function(clazz){\n    var path;\n    switch(clazz) {\n        case 'home':\n        path = 'Home';\n        break;\n        case 'forum':\n        path = 'Forum';\n         break;\n    }\n    if(path){\n        return 'assets/js/project/' + path + '.js';\n    } else {\n          return '';\n    }\n}\n\n...\n\nvar formPathBuilder = {\nbuildPath: function(){...}\n}\nvar utilsPathBuilder = {\nbuildPath: function(){...}\n}\nvar projectPathBuilder = {\nbuildPath: function(){...}\n}\n\nEngine.pathBuilder = [formPathBuilder, utilsPathBuilder, projectPathBuilder]\n</code>\n<p>\nДля инициализации объекта больше ничего не требуется. Это обычный javascript объект, который не имеет конструкторов, и не может иметь экземпляров класса.\n</p>\n<p>\n  Engine имеет следующие функции \n</p>\n<table>\n<tr>\n<th>Функция</th>\n<th>Аргументы</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_load\">load</a></td>\n  <td>module (строка)<br>clb(функция)</td>\n  <td>Этот метод воспользуется <code>pathBuilder</code> полем объекта <code>Engine</code> для того чтобы построить путь к нужному js файлу используя аргумент <code>module</code>, и загрузит его. После загрузки файла он (при необходимости) загрузит зависимости, и когда все зависимости были загружены, выполнит <code>clb</code> функцию.<br/>\nЭта функция должна быть вызвана пользователем один раз, для того чтобы инициализировать приложение.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info/#sample_define\">define</a></td>\n  <td>moduleName (строка)<br>dependencies(строка либо массив строк)<br/>module(любой объект)</td>\n  <td>С вызова этого метода должен начинаться любой модуль фреймворка. Если метод получает только два аргумента, то считается что зависимостей нет, а содержимое модуля это второй аргумент. Если dependencies - строка, то считается что модуль имеет только одну зависимость. Если содержимое модуля это функция, то после разрешения всех зависимостей эта функция будет выполнена, и модулем будет возвращаемый результат функции. Это сделано для создания функции-класса внутри модуля с прототипным наследованием\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_require\">require</a></td>\n  <td>moduleName (строка)</td>\n  <td>Этот метод вернет модуль, или бросит исключение, если модуль не инициализирован. Это сделано для явного объявления зависимостей.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_notify\">notify</a></td>\n  <td>text(строка), тип(строка, одна из [S, I, W, E] (success, info, warning, error)</td>\n  <td>Показывает уведомление для пользователя\n  </td>\n</tr>\n<tr>\n  <td>findPath(module)</td>\n  <td>module(строка)</td>\n  <td>Ищет путь к модулю. Этот метод может быть заменен на другой, но в этом нет смысла, поскольку можно установить массив pathBuilder'ов\n  </td>\n</tr>\n</table>\n\n<p>\n  Engine имеет следующие поля \n</p>\n<table>\n<tr>\n<th>Поле</th>\n<th>Тип</th>\n<th>По умолчанию</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_path_builder\">pathBuilder</a></td>\n  <td>null|function|array</td>\n  <td>null</td>\n  <td>\n    <code>Engine</code> использует это поле для построения пути к скрипту по названию класса. Если поле равно <code>null</code>, то все скрипты будут браться из источника <code>assets/js/`имя модуля`.js</code>. Если поле является функцией, то для построения пути будет использоваться она, получая один аргумент - название класса. Если поле является массивом, то каждый элемент массива должен иметь функцию buildPath. Первым будет вызван последний добавленный объект. Как только такой объект возвращает не пустую строку, цикл построения пути прерывается.\n  </td>\n</tr>\n<tr>\n <td>limit</td>\n  <td>integer</td>\n  <td>500</td>\n  <td>\n    Иногда во время разработки получается создать два класса, которые зависят друг от друга. Это означает только плохую бизнес-логику в проектировании компонент. В этом случае объект <code>Engine</code> обычно отъедает всю доступную память, и потом падает с ошибкой max call stack exceed. При каждой попытке загрузить скрипт, <code>Engine</code> декрементирует свое поле <code>limit</code>, и по достижению им 0 выбрасывает исключение. Если проект большой, то рекомендуется увеличить это поле до 2000. \n  </td>\n</tr>\n<tr>\n  <td>log</td>\n  <td>boolean</td>\n  <td>true</td>\n  <td>Если это поле равно <code>true</code>, то при каждой загрузке скрипта <code>Engine</code> будет показывать уведомление.</td>\n</tr>\n<tr>\n  <td>modules</td>\n  <td>object</td>\n  <td>{}</td>\n  <td>В этом поле Engine содержит все загруженные модули. В теории, доступ к этому полю не нужен, поскольку есть такой метод как <code>Engine.require('MyModule')</code>, который выбросит исключение если модуль не загружен, в то время как <code>Engine.modules.MyModule</code> может вернуть <code>undefined</code>.\n  </td>\n</tr>\n</table>\n\n\n<code id=\"sample_load\">\nEngine.load('AppStartup', function(){\n  var AppStartup = Engine.require(AppStartup();\n  AppStartup.start();\n});\n</code>\n\n<code id=\"sample_define\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var MyModule = function(){\n    ...\n  }\n  MyModule.prototype.loadData = function(){...}\n  return MyModule;\n});\n</code>\n\n<code id=\"sample_require\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var Dom = Engine.require('Dom');\n  var Rest = Engine.require('Rest');\n\n\n  var MyModule = function(){\n    this.container = Dom.el('div');\n  }\n  MyModule.prototype.loadData = function(){\n     Rest.doGet(\n        'myapp-load-data'\n     ).then(\n        function(){...}\n     )\n  }\n  return MyModule;\n});\n</code>\n\n\n<code id=\"sample_notify\">\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded');return false\">Engine.notify('Data was loaded');</a>\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded', 'S');return false\">Engine.notify('Data was loaded', 'S');</a>\n<a href=\"#\" onclick=\"Engine.notify('Info message', 'I');return false\">Engine.notify('Info message', 'I');</a>\n<a href=\"#\" onclick=\"Engine.notify('Warning message', 'W');return false\">Engine.notify('Warning message', 'W');</a>\n<a href=\"#\" onclick=\"Engine.notify('Fail to load data', 'E');return false\">Engine.notify('Fail to load data', 'E');</a>\n</code>",
  "routes_info_content": "<h1>Маршрутизация</h1>\n<p>\nДля маршрутизации в фреймворке предусмотрен один класс <code class=\"inline\">Dispatcher</code>. Этот класс отвечает за запуск определенного приложения для соответствующего URL ресурса, и завершение работы предыдущего приложения (например, при переходе по ссылке внутри приложения-одностраничника). Этот класс имеет поле <code class=\"inline\">UrlReolver</code>, который отвечает за разбор URL и поиск соответствующего приложения, но, по умолчанию оно инстанциируется автоматически, и скорее всего здесь ничего переопределять не потребуется.\n</p>\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет конструктор и методы:\n</p>\n<table>\n<tr>\n  <th>Метод</th><th>аргументы</th><th>описание</th>\n</tr>\n\n<tr>\n  <td>Конструктор</td><td>appNode[string|Dom node]<br/>context[object]<br/>config[object|Config]<br/>urlResolver[UrlResolver|null]</td><td>Для создания экземпляра класса нужно вызвать конструктор как минимум с одним параметром <code>appNode</code>. Это может быть строка-идентификатор существующего DOM элемента, либо DOM элемент. Context может быть не передан, тогда вместо него будет создан простой объект. <code>Dispatcher</code> будет хранить в этом элементе состояние запроса - <code>{request: {url: \"current/url\", params: {url: params}}}</code>. Config может быть не передан, тогда вместо него будет создан обычный объект. Рекомендуется передавать сюда экземпляр класса <code>Config</code>. <code>UrlResolver</code> не является обязательным параметром, и его передавать не рекомендуется, поскольку его реализация есть в фреймворке.</td>\n</tr>\n\n\n<tr>\n  <td>addMapping</td><td>className[string]<br/>url[string]</td><td>Этот метод связывает URL ресурса с требуемым приложением. Примеры вызова метода:<br/>\n<code>dispatcher.addMapping('Forum', 'forum')</code><br/>\n<code>dispatcher.addMapping('Topic', 'forum/topic/:id')</code><br/>\nВо втором случае, при URL 'forum/topic/12' приложение <code>Topic</code> сможет использовать <code>context.request.params.id</code>, который будет равен 12.\n</td>\n</tr>\n\n<tr>\n  <td>addListener</td><td>name[string|function]<br/>listener[function|undefined]</td><td>При размещении приложения <code>dispatcher</code> генерирует 4 события - <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>. Первый аргумент должен быть одним из них, а второй аргумент должен быть функцией. Если передан только один аргумент, то это должна быть функция, а названием события в этом случае будет <code>afterOpen</code>.\n</td>\n</tr>\n\n\n<tr>\n  <td>placeApplication</td><td>url[string|null]<br/>directives[mixed]</td><td>Этот метод используется для размещения нового приложения. Если метод не получает параметров, то используется текущий URL ресурса, если передан один параметр, то он будет использован как URL. Если передан второй параметр, то он будет передан в такие методы приложения как beforeOpen и afterOpen.\n</td>\n</tr>\n\n<tr>\n  <td>placeApplication</td><td>eventType[string]<br/>applicationName[string]</td><td>Этот метод триггерит событие, вызывая всех слушателей, которые на него подписаны. Первый аргумент обязателен, и он должен быть одним из <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>.\n</td>\n</tr>\n\n</table>\n\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет следующие поля:\n</p>\n<table>\n<tr>\n  <th>Поле</th><th>Тип</th><th>По умолчанию</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>app</td><td>DOM node</td><td>null</td><td>Это поле хранит DOM node, в которую будет положено активное приложение. Это обязательное поле, которое инстанциируется при создании экземпляра класса. Для его инстанциации первый аргумент конструктора должен быть строкой или DOM node. Если передаваемый параметр строка, то она должна соответствовать идентификатору существующего элемента.</td>\n</tr>\n<tr>\n  <td>context</td><td>object</td><td>{}</td><td>Это поле создано для передачи объектов между приложениями в течении работы системы. Это контекст приложения, в который можно положить что угодно, например какие-то результаты работы приложения, сервисы, результаты ajax-запросов и проч.</td>\n</tr>\n\n<tr>\n  <td>config</td><td>Config</td><td>{}</td><td>Это поле похоже на предыдущее, только с тем отличием, что в нем должны храниться настройки приложения, или какие-то предпочтения пользователя. Желательно хранить здесь простые конструкции типа <code>{string:string}</code>. Лучшим выбором будет использование класса Config, поскольку он использует localStorage для сохранения состояний между сессиями.</td>\n</tr>\n\n<tr>\n  <td>applications</td><td>object</td><td>{}</td><td>Здесь экземпляр класса <code>Dispatcher</code> хранит загруженные приложения. В теории доступ к полю не должен понадобиться, поскольку это поле было создано для внутреннего использования.</td>\n</tr>\n\n<tr>\n  <td>activeApplication</td><td>object</td><td>null</td><td>Это текущее развернутое приложение. О приложениях стоит говорить отдельно.</td>\n</tr>\n\n<tr>\n  <td>history</td><td>BrowserHistory</td><td>BrowserHistory</td><td>Объект истории браузера, используется для навигации и подписки на события о смене URL ресурса.</td>\n</tr>\n\n<tr>\n  <td>urlResolver</td><td>object</td><td>UrlResolver</td><td>Объект с двумя методами - <code>addMapping(appName, url)</code> и <code>resolve(url)</code>. Метод <code>addMapping</code> должен быть использован для всех приложений вашего веб ресурса.</td>\n</tr>\n\n<tr>\n  <td>events</td><td>object</td><td>null</td><td><code>Dispatcher</code> может подписать какие-то объекты на 4 события развертки приложения - 'beforeOpen', 'afterOpen', 'beforeClose', 'afterClose'. Поле сделано для внутреннего использования.</td>\n</tr>\n</table>",
  "routes_application_content": "<h1>Приложения</h1>",
  "routes_dispatcher_content": "<h1>Диспетчер</h1>",
  "routes_url_resolver_content": "<h1>URL Resolver</h1>"
}