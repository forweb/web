{
  "menu_home": "Главная",
  "menu_engine": "Движок",
  "menu_utils": "Утилиты",
  "menu_utils_ajax": "Ajax",
  "menu_utils_rest": "Rest",
  "menu_utils_dom": "Dom",
  "menu_utils_config": "Config",
  "menu_utils_string_utils": "StringUtils",
  "menu_utils_url_utils": "UrlUtils",
  "menu_utils_screen_utils": "ScreenUtils",
  "menu_utils_keyboard_utils": "KeyboardUtils",
  "menu_forms": "Формы",
  "menu_word": "Языки",
  "menu_components": "Компоненты",
  "menu_routes": "Маршрутизация",
  "menu_routes_url_resolver": "Разбор URL",
  "menu_routes_applications": "Приложения",
  "menu_routes_dispatcher": "Диспетчер",
  "page_404_content": "<h1>404</h1><p>Такой страницы не существует</p>",
  "home_info_content": "<p>\n  Javascript клиентский фреймворк от компании forweb.org включает в себя несколько модулей для создания интерактивных веб приложений. Скачать его можно тут - <a href=\"https://github.com/forweb/core\">https://github.com/forweb/core</a>.\nЧто же в нем такого особенного?\n  </p>\n  <ul>\n  <li>\n  Модульность. Единственный объект глобальной видимости - Engine.\n  </li>\n  <li>\n  Модульность. Каждый класс находится в отдельном файле, может иметь ряд зависимостей, и не будет инициализирован до инициализации всех зависимостей.\n  </li>\n  <li>\n  Модульность. Приложение может быть (а может и не быть) разделено на множество отдельный js файлов, что позволяет разбить тяжелые приложения (размером 10мб, например) на несколько легковесных файлов, которые будут динамически подгружены по мере необходимости.\n  </li>\n  <li>\n  Принципы ООП программирования\n  </li>\n  <li>\n  Легко интегрируется с другими технологиями и фреймворками, такими как npm, jquery, prototypejs и проч. (предположительно, легко интегрируется с любыми технологиями)\n  </li>\n  <li>\n  Имеет базовый набор компонент, таких как элементы форм, панель вкладок, модальные окна, гриды\n  </li>\n  <li>\n  Имеет модуль интернационализации</li>\n  <li>\n  Имеет AJAX и AJAX-Rest модули для работы с AJAX запросами основанные на Promise\n  </li>\n  <li>\n  Имеет модуль маршрутизации\n  </li>\n<li>Спроектирован для single-page приложений</li>  </ul>\n  <p>\n  Модульность, компоненты, ajax, маршрутизация, ООП, интернационализация, 28кб. Почему бы и не <a href=\"/utils/dom\">начать</a>?\n  </p>",
  "engine_info_content": "<p>Engine - ключевой объект фреймворка, и единственный объект глобальной видимости. Он ответственен за динамическую подгрузку скриптов и разрешение зависимостей. Так вышло, что помимо своих функций, объект способен отображать пользовательские уведомления.\n</p>\n  <p>\n  Для того чтобы загружать модули, движок должен иметь посредника, который будет находить путь к скрипту согласно имени класса. Для этого используется поле pathBuilder, которое может быть null, массивом либо функцией. Если это функция, то она будет принимать один аргумент - имя класса, и возвращать путь к скрипту. Если это массив, то это должен быть массив объектов, каждый из которых имеет функцию buildPath, которая также принимает имя класса. В случае с массивом, первым пытаться построить путь к скрипту будет последний добавленный объект. Если объект возвращает пустую строку, то следующий объект будет пытаться построить путь. Если ни один объект не может построить путь, то будет выброшено исключение.\n</p>\n  <code id=\"sample_path_builder\">\nEngine.pathBuilder = function(clazz){\n    var path;\n    switch(clazz) {\n        case 'home':\n        path = 'Home';\n        break;\n        case 'forum':\n        path = 'Forum';\n         break;\n    }\n    if(path){\n        return 'assets/js/project/' + path + '.js';\n    } else {\n          return '';\n    }\n}\n\n...\n\nvar formPathBuilder = {\nbuildPath: function(){...}\n}\nvar utilsPathBuilder = {\nbuildPath: function(){...}\n}\nvar projectPathBuilder = {\nbuildPath: function(){...}\n}\n\nEngine.pathBuilder = [formPathBuilder, utilsPathBuilder, projectPathBuilder]\n</code>\n<p>\nДля инициализации объекта больше ничего не требуется. Это обычный javascript объект, который не имеет конструкторов, и не может иметь экземпляров класса.\n</p>\n<p>\n  Engine имеет следующие функции \n</p>\n<table>\n<tr>\n<th>Функция</th>\n<th>Аргументы</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_load\">load</a></td>\n  <td>module (строка)<br>clb(функция)</td>\n  <td>Этот метод воспользуется <code>pathBuilder</code> полем объекта <code>Engine</code> для того чтобы построить путь к нужному js файлу используя аргумент <code>module</code>, и загрузит его. После загрузки файла он (при необходимости) загрузит зависимости, и когда все зависимости были загружены, выполнит <code>clb</code> функцию.<br/>\nЭта функция должна быть вызвана пользователем один раз, для того чтобы инициализировать приложение.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info/#sample_define\">define</a></td>\n  <td>moduleName (строка)<br>dependencies(строка либо массив строк)<br/>module(любой объект)</td>\n  <td>С вызова этого метода должен начинаться любой модуль фреймворка. Если метод получает только два аргумента, то считается что зависимостей нет, а содержимое модуля это второй аргумент. Если dependencies - строка, то считается что модуль имеет только одну зависимость. Если содержимое модуля это функция, то после разрешения всех зависимостей эта функция будет выполнена, и модулем будет возвращаемый результат функции. Это сделано для создания функции-класса внутри модуля с прототипным наследованием\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_require\">require</a></td>\n  <td>moduleName (строка)</td>\n  <td>Этот метод вернет модуль, или бросит исключение, если модуль не инициализирован. Это сделано для явного объявления зависимостей.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_notify\">notify</a></td>\n  <td>text(строка), тип(строка, одна из [S, I, W, E] (success, info, warning, error)</td>\n  <td>Показывает уведомление для пользователя\n  </td>\n</tr>\n<tr>\n  <td>findPath(module)</td>\n  <td>module(строка)</td>\n  <td>Ищет путь к модулю. Этот метод может быть заменен на другой, но в этом нет смысла, поскольку можно установить массив pathBuilder'ов\n  </td>\n</tr>\n</table>\n\n<p>\n  Engine имеет следующие поля \n</p>\n<table>\n<tr>\n<th>Поле</th>\n<th>Тип</th>\n<th>По умолчанию</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_path_builder\">pathBuilder</a></td>\n  <td>null|function|array</td>\n  <td>null</td>\n  <td>\n    <code>Engine</code> использует это поле для построения пути к скрипту по названию класса. Если поле равно <code>null</code>, то все скрипты будут браться из источника <code>assets/js/`имя модуля`.js</code>. Если поле является функцией, то для построения пути будет использоваться она, получая один аргумент - название класса. Если поле является массивом, то каждый элемент массива должен иметь функцию buildPath. Первым будет вызван последний добавленный объект. Как только такой объект возвращает не пустую строку, цикл построения пути прерывается.\n  </td>\n</tr>\n<tr>\n <td>limit</td>\n  <td>integer</td>\n  <td>500</td>\n  <td>\n    Иногда во время разработки получается создать два класса, которые зависят друг от друга. Это означает только плохую бизнес-логику в проектировании компонент. В этом случае объект <code>Engine</code> обычно отъедает всю доступную память, и потом падает с ошибкой max call stack exceed. При каждой попытке загрузить скрипт, <code>Engine</code> декрементирует свое поле <code>limit</code>, и по достижению им 0 выбрасывает исключение. Если проект большой, то рекомендуется увеличить это поле до 2000. \n  </td>\n</tr>\n<tr>\n  <td>log</td>\n  <td>boolean</td>\n  <td>true</td>\n  <td>Если это поле равно <code>true</code>, то при каждой загрузке скрипта <code>Engine</code> будет показывать уведомление.</td>\n</tr>\n<tr>\n  <td>modules</td>\n  <td>object</td>\n  <td>{}</td>\n  <td>В этом поле Engine содержит все загруженные модули. В теории, доступ к этому полю не нужен, поскольку есть такой метод как <code>Engine.require('MyModule')</code>, который выбросит исключение если модуль не загружен, в то время как <code>Engine.modules.MyModule</code> может вернуть <code>undefined</code>.\n  </td>\n</tr>\n</table>\n\n\n<code id=\"sample_load\">\nEngine.load('AppStartup', function(){\n  var AppStartup = Engine.require(AppStartup();\n  AppStartup.start();\n});\n</code>\n\n<code id=\"sample_define\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var MyModule = function(){\n    ...\n  }\n  MyModule.prototype.loadData = function(){...}\n  return MyModule;\n});\n</code>\n\n<code id=\"sample_require\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var Dom = Engine.require('Dom');\n  var Rest = Engine.require('Rest');\n\n\n  var MyModule = function(){\n    this.container = Dom.el('div');\n  }\n  MyModule.prototype.loadData = function(){\n     Rest.doGet(\n        'myapp-load-data'\n     ).then(\n        function(){...}\n     )\n  }\n  return MyModule;\n});\n</code>\n\n\n<code id=\"sample_notify\">\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded');return false\">Engine.notify('Data was loaded');</a>\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded', 'S');return false\">Engine.notify('Data was loaded', 'S');</a>\n<a href=\"#\" onclick=\"Engine.notify('Info message', 'I');return false\">Engine.notify('Info message', 'I');</a>\n<a href=\"#\" onclick=\"Engine.notify('Warning message', 'W');return false\">Engine.notify('Warning message', 'W');</a>\n<a href=\"#\" onclick=\"Engine.notify('Fail to load data', 'E');return false\">Engine.notify('Fail to load data', 'E');</a>\n</code>",
  "routes_info_content": "<h1>Маршрутизация</h1>\n<p>\nДля маршрутизации в фреймворке предусмотрено два класса - <code class=\"inline\">Dispatcher</code>, <code class=\"inline\">UrlReolver</code> и интерфейс приложения. Приложение - объект JS, который ответственен за отображение пользовательской информации. Эти классы сделаны для создания полноценных single-page приложений, с нормальными, человекопонятными URL.\n</p>\n\n<p class=\"danger\">\nДля нормальной работы маршрутизации нужна единая точка входа, и поэтому, скорее всего, потребуется дополнительно настраивать сервер. Настройки различаются от сервера к серверу, и эти настройки не имеет отношение к клинетскому фреймворку ForWeb, поэтому они рассматриваться не будут.\n</p>\n\n<p>\nНастройки маршрутизации довольно гибкие, и позволяют привязывать приложения к динамическим параметризованным URL:\n</p>\n<ul>\n<li>/application</li>\n<li>/application/:theme</li>\n<li>/application/*</li>\n</ul>\n<p class=\"info\">\nВо втором случае приложение будет иметь в распоряжении объект context.request.params.theme\n</p>\n\n<p>\nКроме развертывания приложений диспетчер может вызывать события по мере инициализации новых приложений, что удобно использовать в меню, которое должно быть отображено всегда, не зависимо от текущего приложения.\n</p>",
  "routes_application_content": "<h1>Приложения</h1>\n<p>\nПриложение это объект, используемый <a href=\"/routes-info/dispatcher\">диспетчером</a> для отображения контента. Приложение может быть функцией либо объектом. В случае если приложение это функция, то для отображения контента диспетчер попытается создать экземпляр используя ключевое слово <code class=\"inline\">new</code>, передав в конструктор три аргумента - <code class=\"inline\">context</code>, <code class=\"inline\">config</code>, <code class=\"inline\">placeApplication</code>. Если приложение это объект, то при наличии метода <code class=\"inline\">init</code> диспетчер вызовет его, передав туда те же самые три параметра. Параметр <code class=\"inline\">context</code> используется для передачи и хранения данных в течении работы приложения, в частности там хранятся данные о URL ресурса, <code class=\"inline\">config</code> используется для хранения настроек пользователя (при помощи localStorage), и третий параметр <code class=\"inline\">placeApplication</code> это функция, которая позволяет сменить активное приложение. Для этого функцию надо вызвать с одним, или с двумя параметрами. Первый обязательный параметр - URL ресурса. Диспетчер совершит разбор URL, вставит его в командную строку, и разместит новое приложение. Второй параметр это дополнительные директивы, которое могут быть использованы приложением, они будут переданы в методы <code class=\"inline\">beforeOpen</code> и <code class=\"inline\">afterOpen</code> нового приложения.\n</p>\n<p class=\"warning\">\nПри разработке не рекомендуется в качестве приложения использовать объект. Если все же используется объект, то нужно учесть, что метод <code class=\"inline\">init</code> будет вызван столько раз, сколько раз будет размещаться приложение. Также не рекомендуется использование директив, поскольку приложение должно получать все данные из URL ресурса. Директивы сделаны для тех случаев, когда запрашиваемая страница не может быть инстанцирована без вмешательства другого приложения.\n</p>\n<p>\nКаждое приложение имеет свой жизненный цикл. Этот цикл имеет следующие этапы \n</p>\n<dl>\n<dt>beforeOpen</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после инстанциации приложения, но до размещения поля <code class=\"inline\">container</code> в DOM страницы</dd>\n\n<dt>afterOpen</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после размещения поля <code class=\"inline\">container</code> в DOM страницы</dd>\n\n<dt>Жизнь приложения<dt>\n<dd>Время, в течении которого пользователь взаимодействует с приложением</dt>\n\n<dt>beforeClose</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван до удаления поля <code class=\"inline\">container</code> из DOM страницы</dd>\n\n<dt>afterClose</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после удаления поля <code class=\"inline\">container</code> из DOM страницы</dd>\n</dl>\n<p>\nКроме этого, приложение может иметь множество различных URL. В таком случае, приложение может продолжить свое выполнение, если оно имеет метод <code class=\"inline\">canStay</code>, и если этот метод возвращает не <code class=\"inline\">false</code>. Например, как видно отсюда - <a href=\"https://github.com/forweb/web/blob/master/assets/js/project/Application.js\" target=\"_blank\">js/project/Application.js</a> приложение под названием <code class=\"inline\">RoutesInfo</code> имеет два URL - 'routes-info' и 'routes-info/:app'. Различие в маршрутах только в тексте основного содержимого, поэтому нет смысла заново создавать боковое меню. Посмотреть реализацию  <code class=\"inline\">RoutesInfo</code> можно <a href=\"https://github.com/forweb/web/blob/master/assets/js/project/applications/RoutesInfo.js\" target=\"_blank\">здесь</a>, обратить внимание стоит на метод <code class=\"inline\">canStay</code>.\n</p>\n<p class=\"info\">\nИтого, приложение должно иметь поле <code class=\"inline\">container</code>, может иметь методы <code class=\"inline\">beforeOpen</code>, <code class=\"inline\">afterOpen</code>, <code class=\"inline\">beforeClose</code>, <code class=\"inline\">afterClose</code>, <code class=\"inline\">canStay</code> и в случае если приложение это не функция а объект, то оно может иметь метод <code class=\"inline\">init</code>\n</p>",
  "routes_dispatcher_content": "<h1>Dispatcher</h1>\n<p>\nКлючевым классом для управления страницами является класс <code class=\"inline\">Dispatcher</code>. Этот класс отвечает за инстанциацию, запуск, и завершение работы приложения удовлетворяющего текущему URL ресурса.\n</p>\n\n\n\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет конструктор и методы:\n</p>\n<table>\n<tr>\n  <th>Метод</th><th>аргументы</th><th>описание</th>\n</tr>\n\n<tr>\n  <td>Конструктор</td><td>appNode[string|Dom node]<br/>context[object]<br/>config[object|Config]<br/>urlResolver[UrlResolver|null]</td><td>Для создания экземпляра класса нужно вызвать конструктор как минимум с одним параметром <code>appNode</code>. Это может быть строка-идентификатор существующего DOM элемента, либо DOM элемент. Context может быть не передан, тогда вместо него будет создан простой объект. <code>Dispatcher</code> будет хранить в этом элементе состояние запроса - <code>{request: {url: \"current/url\", params: {url: params}}}</code>. Config может быть не передан, тогда вместо него будет создан обычный объект. Рекомендуется передавать сюда экземпляр класса <code>Config</code>. <code>UrlResolver</code> не является обязательным параметром, и его передавать не рекомендуется, поскольку его реализация есть в фреймворке.</td>\n</tr>\n\n\n<tr>\n  <td>addMapping</td><td>className[string]<br/>url[string]</td><td>Этот метод связывает URL ресурса с требуемым приложением. Примеры вызова метода:<br/>\n<code>dispatcher.addMapping('Forum', 'forum')</code><br/>\n<code>dispatcher.addMapping('Topic', 'forum/topic/:id')</code><br/>\nВо втором случае, при URL 'forum/topic/12' приложение <code>Topic</code> сможет использовать <code>context.request.params.id</code>, который будет равен 12.\n</td>\n</tr>\n\n<tr>\n  <td>addListener</td><td>name[string|function]<br/>listener[function|undefined]</td><td>При размещении приложения <code>dispatcher</code> генерирует 4 события - <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>. Первый аргумент должен быть одним из них, а второй аргумент должен быть функцией. Если передан только один аргумент, то это должна быть функция, а названием события в этом случае будет <code>afterOpen</code>.\n</td>\n</tr>\n\n\n<tr>\n  <td>placeApplication</td><td>url[string|null]<br/>directives[mixed]</td><td>Этот метод используется для размещения нового приложения. Если метод не получает параметров, то используется текущий URL ресурса, если передан один параметр, то он будет использован как URL. Если передан второй параметр, то он будет передан в такие методы приложения как beforeOpen и afterOpen.\n</td>\n</tr>\n\n<tr>\n  <td>placeApplication</td><td>eventType[string]<br/>applicationName[string]</td><td>Этот метод триггерит событие, вызывая всех слушателей, которые на него подписаны. Первый аргумент обязателен, и он должен быть одним из <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>.\n</td>\n</tr>\n\n</table>\n\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет следующие поля:\n</p>\n<table>\n<tr>\n  <th>Поле</th><th>Тип</th><th>По умолчанию</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>app</td><td>DOM node</td><td>null</td><td>Это поле хранит DOM node, в которую будет положено активное приложение. Это обязательное поле, которое инстанциируется при создании экземпляра класса. Для его инстанциации первый аргумент конструктора должен быть строкой или DOM node. Если передаваемый параметр строка, то она должна соответствовать идентификатору существующего элемента.</td>\n</tr>\n<tr>\n  <td>context</td><td>object</td><td>{}</td><td>Это поле создано для передачи объектов между приложениями в течении работы системы. Это контекст приложения, в который можно положить что угодно, например какие-то результаты работы приложения, сервисы, результаты ajax-запросов и проч.</td>\n</tr>\n\n<tr>\n  <td>config</td><td>Config</td><td>{}</td><td>Это поле похоже на предыдущее, только с тем отличием, что в нем должны храниться настройки приложения, или какие-то предпочтения пользователя. Желательно хранить здесь простые конструкции типа <code>{string:string}</code>. Лучшим выбором будет использование класса Config, поскольку он использует localStorage для сохранения состояний между сессиями.</td>\n</tr>\n\n<tr>\n  <td>applications</td><td>object</td><td>{}</td><td>Здесь экземпляр класса <code>Dispatcher</code> хранит загруженные приложения. В теории доступ к полю не должен понадобиться, поскольку это поле было создано для внутреннего использования.</td>\n</tr>\n\n<tr>\n  <td>activeApplication</td><td>object</td><td>null</td><td>Это текущее развернутое приложение. О приложениях стоит говорить отдельно.</td>\n</tr>\n\n<tr>\n  <td>history</td><td>BrowserHistory</td><td>BrowserHistory</td><td>Объект истории браузера, используется для навигации и подписки на события о смене URL ресурса. По умолчанию используется история браузера</td>\n</tr>\n\n<tr>\n  <td>urlResolver</td><td>object</td><td>UrlResolver</td><td>Объект с двумя методами - <code>addMapping(appName, url)</code> и <code>resolve(url)</code>. Это поле отвечает за разбор URL и поиск соответствующего приложения. Для его инстанциации нужно передать 4 параметр в конструктор класса <code>Dispatcher</code>, если же четвертый параметр будет пустым, то диспетчер создаст его сам.</td>\n</tr>\n\n<tr>\n  <td>events</td><td>object</td><td>null</td><td><code>Dispatcher</code> может подписать какие-то объекты на 4 события развертки приложения - 'beforeOpen', 'afterOpen', 'beforeClose', 'afterClose'. Поле сделано для внутреннего использования.</td>\n</tr>\n</table>",
  "routes_url_resolver_content": "<h1>Разбор URL ресурса</h1>\n<p><code class=\"inline\">Dispatcher</code> отвечает за развертывание приложений, но для того чтобы понять какое именно приложение должно быть развернуто, он нуждается в экземпляре <code class=\"inline\">UrlResolver</code>. Этот класс не требует инициализации со стороны пользователя, поскольку объект <code class=\"inline\">Dispatcher</code> делает это сам, но, при необходимости, он может быть переопределен. Главная задача этого класса - получить URL ресурса, и сказать какое приложение диспетчер должен развернуть и с какими параметрами. Для этого используются следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Параметры</th><th>Возвращаемое значение</th><th>Описание</th>\n</tr>\n<tr>\n  <td>Конструктор</td>\n  <td>path(string)</td>\n  <td>this</td>\n  <td>Конструктор класса</td>\n</tr>\n<tr>\n  <td>resolve</td>\n  <td>url(string)</td>\n  <td>object{params:object,app:string,url:string}</td>\n  <td>Метод разбирает URL и ищет подходящее приложение. Кроме этого, в процессе поиска приложения, класс создает объект params (если параметры есть). Например, если для приложения <code>Forum</code> используется такой URL \"forum/:topic\", и в метод приходит <code>\"forum/10\"</code>, то объект <code>params</code> будет выглядеть так: <code>{topic:10}</code>.</td>\n</tr>\n<tr>\n  <td>addMapping</td>\n  <td>className(string)<br/>url(string)</td>\n  <td>void|throw exception</td>\n  <td>Метод связывает имя класса и URL. Рабочими URL являются следующие шаблоны <code>\"forum\"</code>, <code>\"forum/:topic\"</code>, <code>\"/forum/:topic/*\"</code>. В последнем случае <code>*</code> будет означать что угодно. Если маппинг уже существует, например, уже есть \"forum/:topic\", и совершается попытка добавить маппинг на \"forum:id\" метод выбросить исключение.</td>\n</tr>\n<tr>\n  <td>parseUrl</td>\n  <td>url(string)</td>\n  <td>[]</td>\n  <td>Метод сделан для внутреннего использования. Возвращает массив объектов, с информацией о каждом сегменте URL. Например для <code>\"forum/:topic\"</code> результатом будет <code>[{name:forum,dynamic:false},{name:topic, dynamic: true}]</code></td>\n</tr>\n\n</table>",
  "utils_info_content": "<h1>Классы - утилиты</h1>\n<p>\nФреймворк содержит набор вспомогательных классов-утилит, которые будут полезны при разработке. Они облегчают работу с DOM-элементами, с ajax-запросами, обработкой событий, изменением адресной строки и при работе со строками. Также, классы-утилиты используются повсеместно в компонентах фреймворка.\n</p>",
  "utils_info_ajax_content": "<h1>Ajax</h1>\n<p>Этот класс сделан как прослойка облегчающая работу с XmlHttpRequest. Реализация класса - простой JS объект, поэтому создание экземпляров не требуется.</p>\n<p class=\"warning\">\nИспользование этого класса не рекомендуется, поскольку в фреймворке есть класс с более удобным API - <code class=\"inline\">Rest</code>.\n</p>\n<p>Класс имеет следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>ajax</td>\n  <td>data(Object)<br>resolve(Function)<br>reject(Function)</td>\n  <td>void</td>\n  <td>Основной метод класса, который совершает отправку данных при помощи XmlHttpRequest. В случае успеха (если статус ответа 200 (если статус ответа между 199 и 300)) вызывается функция <code>resolve</code>, где первым аргументом будет ответ от сервера, вторым будет объект XmlHttpRequest. В другом случае вызывается функция <code>Reject</code>, если она была передана, в которую первым аргументом будет передан объект XmlHttpRequest. Объект <code>data</code> может содержать следующие ключи:type, url, data, headers, responseType. <code>type</code> это обязательный ключ, который означает тип запроса - get, post, put и проч. <code>url</code> это обязательный ключ, который должен быть равен URL запрашиваемого ресурса. <code>data</code> это необязательный ключ, который является строковым представлением отправляемых данных. <code></code>headers это необязательный ключ, который может содержать объект из пар ключ-значение для выставления нужных заголовков запроса. Эти заголовки имеют больший приоритет, нежели заголовки из поля <code>Ajax.headers</code>. <code>responseType</code> это ключ, который означает тип возвращаемых данных. Может быть <code>json</code> или <code>text</code></td>\n</tr>\n\n<tr>\n  <td>process</td>\n  <td>xhr(Object)<br>type(string)</td>\n  <td>String|Object</td>\n  <td>\n     Метод для внутреннего использования. Нужен для того чтобы подготовить ответ от сервера. В случае, если <code>data.responseType</code> был равен <code>text</code> будет возвращено значение xhr.responseText, в ином случае будет возвращен результат <code>JSON.parse(xhr.responseText)</code>.\n  </td>\n</tr>\n\n<tr>\n  <td>getXhr</td>\n  <td></td>\n  <td>object</td>\n  <td>\n    Кроссбраузерное получение объекта XmlHttpRequest\n  </td>\n</tr>\n</table>\n\n\nКласс имеет следующие поля:\n<table>\n<tr>\n<th>Поле</th><th>Тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>headers</td>\n  <td>null|object</td>\n  <td>Этот объект содержит информацию о заголовках, которые будут добавлены во все сущности XmlHttpRequest. Например, если объект будет равен <code>{\"Content-type\", \"application/json\"}</code>, то каждый запрос будет иметь заголовок <code>\"Content-type: application/json\"</code>. Это поле имеет меньший приоритет, нежели объект <code>data.headers</code>, который может быть передан в метод <code>ajax</code>.</td>\n</tr>\n</table>",
  "utils_info_rest_content": "<h1>Rest</h1>\n<p>Этот класс сделан для удобной работы с XmlHttpRequest по типу rest-запросов. Реализация класса - простой JS объект, поэтому создание экземпляров не требуется. Класс использует forweb класс <code class=\"inline\">Ajax</code> для отправки данных, и реализацию Promise для последующей обработки ответа. Класс сделан так, что он может отправлять данные только в формате JSON.</p>\n<p class=\"warning\">\nИспользование класса <code class=\"inline\">Rest</code> в браузерах не поддерживающих технологию Promise невозможно. В таких случаях рекомендуется использовать <a href=\"https://github.com/taylorhakes/promise-polyfill\" target=\"_blank\">Promise Polyfill.</a></p>\n<p>Класс имеет следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>doGet</td>\n  <td>url(string)<br>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"get\". Аргумент <code>url</code> это URL запрашиваемого ресурса, а аргумент <code>responseType</code> может быть одним из допустимых типов для класса <code>Ajax</code>.</td>\n</tr>\n\n<tr>\n  <td>doPost</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"post\". Аргумент <code>url</code> это URL запрашиваемого ресурса, аргументом data может быть что угодно, если это не строка или не число, то оно будет преобразовано функцией <code>JSON.stringify</code> а аргумент <code>responseType</code> может быть одним из допустимых типов для класса <code>Ajax</code>.</td>\n</tr>\n\n<tr>\n  <td>doPut</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"put\". В остальном метод идентичен методу <code>doPost</code></td>\n</tr>\n\n<tr>\n  <td>doDelete</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"delete\". В остальном метод идентичен методу <code>doPost</code></td>\n</tr>\n\n</table>\n\n\nКласс имеет следующие поля:\n<table>\n<tr>\n<th>Поле</th><th>Тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>host</td>\n  <td>null|string</td>\n  <td>Это поле сделано для облегчения отправки запросов. Если оно задано, то в начало <code>url</code> каждого запроса будет прибавлено это значение.</td>\n</tr>\n</table>\n\n\n<p>\nПримеры использования:\n</p>\n\n<code>\nRest.host = \"http://my.website.com/\";\n////////////////////////\nRest.doGet(\"users/all\").then(function(users, xhr){\n  console.log(users);\n}, function(xhr){\n  console.log(\"Request fail. Can't load users list\");\n})\n\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doPost(\"users/save\", user).then(function(user, xhr){\n  console.log('user created');\n  console.log(user);\n  console.log(user.id);\n}, function(xhr){\n  console.log(\"Request fail. Can't create user\");\n})\n\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doPut(\"users/save\", user).then(function(user, xhr){\n  console.log('user updated');\n  console.log(user);\n  console.log(user.id);\n}, function(xhr){\n  console.log(\"Request fail. Can't update user\");\n})\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doDelete(\"users/save\", user.id).then(function(response, xhr){\n  console.log('user deleted');\n}, function(xhr){\n  console.log(\"Request fail. Can't delete user\");\n})\n\n</code>"
}