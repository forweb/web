{
  "default": {
    "menu_home": "Главная",
    "menu_engine": "Движок",
    "menu_utils": "Утилиты",
    "menu_utils_ajax": "Ajax",
    "menu_utils_rest": "Rest",
    "menu_utils_dom": "Dom",
    "menu_utils_config": "Config",
    "menu_utils_string_utils": "StringUtils",
    "menu_utils_url_utils": "UrlUtils",
    "menu_utils_screen_utils": "ScreenUtils",
    "menu_forms_abstract_input": "AbstractInput",
    "menu_forms_text": "Text",
    "menu_forms_textarea": "Textarea",
    "menu_forms_radio": "Radio",
    "menu_forms_checkbox": "Checkbox",
    "menu_forms_select": "Select",
    "menu_forms_validation": "Validation",
    "menu_forms_field_meta": "FieldMeta",
    "menu_forms_generic_form": "GenericForm",
    "menu_forms": "Формы",
    "menu_word": "Языки",
    "menu_components": "Компоненты",
    "menu_routes": "Маршрутизация",
    "menu_routes_url_resolver": "Разбор URL",
    "menu_routes_applications": "Приложения",
    "menu_routes_dispatcher": "Диспетчер",
    "generic_form_render_warning": "В случае, когда используется поле 'render', пользователь сам должен позаботиться об обновлении модели данных.",
    "page_404_content": "<h1>404</h1><p>Такой страницы не существует</p>",
    "home_info_content": "<p>\n  Javascript клиентский фреймворк от компании forweb.org включает в себя несколько модулей для создания интерактивных веб приложений. Скачать его можно тут - <a href=\"https://github.com/forweb/core\">https://github.com/forweb/core</a>.\nЧто же в нем такого особенного?\n  </p>\n  <ul>\n  <li>\n  Модульность. Единственный объект глобальной видимости - Engine.\n  </li>\n  <li>\n  Модульность. Каждый класс находится в отдельном файле, может иметь ряд зависимостей, и не будет инициализирован до инициализации всех зависимостей.\n  </li>\n  <li>\n  Модульность. Приложение может быть (а может и не быть) разделено на множество отдельный js файлов, что позволяет разбить тяжелые приложения (размером 10мб, например) на несколько легковесных файлов, которые будут динамически подгружены по мере необходимости.\n  </li>\n  <li>\n  Принципы ООП программирования\n  </li>\n  <li>\n  Легко интегрируется с другими технологиями и фреймворками, такими как npm, jquery, prototypejs и проч. (предположительно, легко интегрируется с любыми технологиями)\n  </li>\n  <li>\n  Имеет базовый набор компонент, таких как элементы форм, панель вкладок, модальные окна, гриды\n  </li>\n  <li>\n  Имеет модуль интернационализации</li>\n  <li>\n  Имеет AJAX и AJAX-Rest модули для работы с AJAX запросами основанные на Promise\n  </li>\n  <li>\n  Имеет модуль маршрутизации\n  </li>\n<li>Спроектирован для single-page приложений</li>  </ul>\n  <p>\n  Модульность, компоненты, ajax, маршрутизация, ООП, интернационализация, 28кб. Почему бы и не <a href=\"/utils/dom\">начать</a>?\n  </p>",
    "engine_info_content": "<p>Engine - ключевой объект фреймворка, и единственный объект глобальной видимости. Он ответственен за динамическую подгрузку скриптов и разрешение зависимостей. Так вышло, что помимо своих функций, объект способен отображать пользовательские уведомления.\n</p>\n  <p>\n  Для того чтобы загружать модули, движок должен иметь посредника, который будет находить путь к скрипту согласно имени класса. Для этого используется поле pathBuilder, которое может быть null, массивом либо функцией. Если это функция, то она будет принимать один аргумент - имя класса, и возвращать путь к скрипту. Если это массив, то это должен быть массив объектов, каждый из которых имеет функцию buildPath, которая также принимает имя класса. В случае с массивом, первым пытаться построить путь к скрипту будет последний добавленный объект. Если объект возвращает пустую строку, то следующий объект будет пытаться построить путь. Если ни один объект не может построить путь, то будет выброшено исключение.\n</p>\n  <code id=\"sample_path_builder\">\nEngine.pathBuilder = function(clazz){\n    var path;\n    switch(clazz) {\n        case 'home':\n        path = 'Home';\n        break;\n        case 'forum':\n        path = 'Forum';\n         break;\n    }\n    if(path){\n        return 'assets/js/project/' + path + '.js';\n    } else {\n          return '';\n    }\n}\n\n...\n\nvar formPathBuilder = {\nbuildPath: function(){...}\n}\nvar utilsPathBuilder = {\nbuildPath: function(){...}\n}\nvar projectPathBuilder = {\nbuildPath: function(){...}\n}\n\nEngine.pathBuilder = [formPathBuilder, utilsPathBuilder, projectPathBuilder]\n</code>\n<p>\nДля инициализации объекта больше ничего не требуется. Это обычный javascript объект, который не имеет конструкторов, и не может иметь экземпляров класса.\n</p>\n<p>\n  Engine имеет следующие функции \n</p>\n<table>\n<tr>\n<th>Функция</th>\n<th>Аргументы</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_load\">load</a></td>\n  <td>module (строка)<br>clb(функция)</td>\n  <td>Этот метод воспользуется <code>pathBuilder</code> полем объекта <code>Engine</code> для того чтобы построить путь к нужному js файлу используя аргумент <code>module</code>, и загрузит его. После загрузки файла он (при необходимости) загрузит зависимости, и когда все зависимости были загружены, выполнит <code>clb</code> функцию.<br/>\nЭта функция должна быть вызвана пользователем один раз, для того чтобы инициализировать приложение.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info/#sample_define\">define</a></td>\n  <td>moduleName (строка)<br>dependencies(строка либо массив строк)<br/>module(любой объект)</td>\n  <td>С вызова этого метода должен начинаться любой модуль фреймворка. Если метод получает только два аргумента, то считается что зависимостей нет, а содержимое модуля это второй аргумент. Если dependencies - строка, то считается что модуль имеет только одну зависимость. Если содержимое модуля это функция, то после разрешения всех зависимостей эта функция будет выполнена, и модулем будет возвращаемый результат функции. Это сделано для создания функции-класса внутри модуля с прототипным наследованием\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_require\">require</a></td>\n  <td>moduleName (строка)</td>\n  <td>Этот метод вернет модуль, или бросит исключение, если модуль не инициализирован. Это сделано для явного объявления зависимостей.\n  </td>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_notify\">notify</a></td>\n  <td>text(строка), тип(строка, одна из [S, I, W, E] (success, info, warning, error)</td>\n  <td>Показывает уведомление для пользователя\n  </td>\n</tr>\n<tr>\n  <td>findPath(module)</td>\n  <td>module(строка)</td>\n  <td>Ищет путь к модулю. Этот метод может быть заменен на другой, но в этом нет смысла, поскольку можно установить массив pathBuilder'ов\n  </td>\n</tr>\n</table>\n\n<p>\n  Engine имеет следующие поля \n</p>\n<table>\n<tr>\n<th>Поле</th>\n<th>Тип</th>\n<th>По умолчанию</th>\n<th>Описание</th>\n</tr>\n<tr>\n  <td><a href=\"/engine-info#sample_path_builder\">pathBuilder</a></td>\n  <td>null|function|array</td>\n  <td>null</td>\n  <td>\n    <code>Engine</code> использует это поле для построения пути к скрипту по названию класса. Если поле равно <code>null</code>, то все скрипты будут браться из источника <code>assets/js/`имя модуля`.js</code>. Если поле является функцией, то для построения пути будет использоваться она, получая один аргумент - название класса. Если поле является массивом, то каждый элемент массива должен иметь функцию buildPath. Первым будет вызван последний добавленный объект. Как только такой объект возвращает не пустую строку, цикл построения пути прерывается.\n  </td>\n</tr>\n<tr>\n <td>limit</td>\n  <td>integer</td>\n  <td>500</td>\n  <td>\n    Иногда во время разработки получается создать два класса, которые зависят друг от друга. Это означает только плохую бизнес-логику в проектировании компонент. В этом случае объект <code>Engine</code> обычно отъедает всю доступную память, и потом падает с ошибкой max call stack exceed. При каждой попытке загрузить скрипт, <code>Engine</code> декрементирует свое поле <code>limit</code>, и по достижению им 0 выбрасывает исключение. Если проект большой, то рекомендуется увеличить это поле до 2000. \n  </td>\n</tr>\n<tr>\n  <td>log</td>\n  <td>boolean</td>\n  <td>true</td>\n  <td>Если это поле равно <code>true</code>, то при каждой загрузке скрипта <code>Engine</code> будет показывать уведомление.</td>\n</tr>\n<tr>\n  <td>modules</td>\n  <td>object</td>\n  <td>{}</td>\n  <td>В этом поле Engine содержит все загруженные модули. В теории, доступ к этому полю не нужен, поскольку есть такой метод как <code>Engine.require('MyModule')</code>, который выбросит исключение если модуль не загружен, в то время как <code>Engine.modules.MyModule</code> может вернуть <code>undefined</code>.\n  </td>\n</tr>\n</table>\n\n\n<code id=\"sample_load\">\nEngine.load('AppStartup', function(){\n  var AppStartup = Engine.require('AppStartup');\n  AppStartup.start();\n});\n</code>\n\n<code id=\"sample_define\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var MyModule = function(){\n    ...\n  }\n  MyModule.prototype.loadData = function(){...}\n  return MyModule;\n});\n</code>\n\n<code id=\"sample_require\">\nEngine.define('MyModule', ['Dom', 'Rest'], function(){\n  var Dom = Engine.require('Dom');\n  var Rest = Engine.require('Rest');\n\n\n  var MyModule = function(){\n    this.container = Dom.el('div');\n  }\n  MyModule.prototype.loadData = function(){\n     Rest.doGet(\n        'myapp-load-data'\n     ).then(\n        function(){...}\n     )\n  }\n  return MyModule;\n});\n</code>\n\n\n<code id=\"sample_notify\">\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded');return false\">Engine.notify('Data was loaded');</a>\n<a href=\"#\" onclick=\"Engine.notify('Data was loaded', 'S');return false\">Engine.notify('Data was loaded', 'S');</a>\n<a href=\"#\" onclick=\"Engine.notify('Info message', 'I');return false\">Engine.notify('Info message', 'I');</a>\n<a href=\"#\" onclick=\"Engine.notify('Warning message', 'W');return false\">Engine.notify('Warning message', 'W');</a>\n<a href=\"#\" onclick=\"Engine.notify('Fail to load data', 'E');return false\">Engine.notify('Fail to load data', 'E');</a>\n</code>",
    "routes_info_content": "<h1>Маршрутизация</h1>\n<p>\nДля маршрутизации в фреймворке предусмотрено два класса - <code class=\"inline\">Dispatcher</code>, <code class=\"inline\">UrlReolver</code> и интерфейс приложения. Приложение - объект JS, который ответственен за отображение пользовательской информации. Эти классы сделаны для создания полноценных single-page приложений, с нормальными, человекопонятными URL.\n</p>\n\n<p class=\"danger\">\nДля нормальной работы маршрутизации нужна единая точка входа, и поэтому, скорее всего, потребуется дополнительно настраивать сервер. Настройки различаются от сервера к серверу, и эти настройки не имеет отношение к клинетскому фреймворку ForWeb, поэтому они рассматриваться не будут.\n</p>\n\n<p>\nНастройки маршрутизации довольно гибкие, и позволяют привязывать приложения к динамическим параметризованным URL:\n</p>\n<ul>\n<li>/application</li>\n<li>/application/:theme</li>\n<li>/application/*</li>\n</ul>\n<p class=\"info\">\nВо втором случае приложение будет иметь в распоряжении объект context.request.params.theme\n</p>\n\n<p>\nКроме развертывания приложений диспетчер может вызывать события по мере инициализации новых приложений, что удобно использовать в меню, которое должно быть отображено всегда, не зависимо от текущего приложения.\n</p>",
    "routes_application_content": "<h1>Приложения</h1>\n<p>\nПриложение это объект, используемый <a href=\"/routes-info/dispatcher\">диспетчером</a> для отображения контента. Приложение может быть классом(функцией) либо объектом. В случае, если приложение является классом(функцией), то для отображения контента диспетчер попытается создать экземпляр, используя ключевое слово <code class=\"inline\">new</code>, передав в конструктор один аргумент - <code class=\"inline\">context</code>. Если приложение это объект, то при наличии метода <code class=\"inline\">init</code> диспетчер вызовет его, передав туда <code class=\"inline\">context</code>. Параметр <code class=\"inline\">context</code> используется для передачи и хранения данных в течении работы всего web-приложения приложения, в частности там хранятся данные о URL ресурса, и объект <code class=\"inline\">Dispatcher</code>.\n</p>\n<p class=\"warning\">\nПри разработке не рекомендуется в качестве приложения использовать объект. Если все же используется объект, то нужно учесть, что метод <code class=\"inline\">init</code> будет вызван столько раз, сколько раз будет размещаться приложение. Также не рекомендуется использование директив, поскольку приложение должно получать все данные из URL ресурса. Директивы сделаны для тех случаев, когда запрашиваемая страница не может быть инстанцирована без вмешательства другого приложения.\n</p>\n<p>\nКаждое приложение имеет свой жизненный цикл. Этот цикл имеет следующие этапы \n</p>\n<dl>\n<dt>beforeOpen</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после инстанциации приложения, но до размещения поля <code class=\"inline\">container</code> в DOM страницы</dd>\n\n<dt>afterOpen</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после размещения поля <code class=\"inline\">container</code> в DOM страницы</dd>\n\n<dt>Жизнь приложения<dt>\n<dd>Время, в течении которого пользователь взаимодействует с приложением</dt>\n\n<dt>beforeClose</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван до удаления поля <code class=\"inline\">container</code> из DOM страницы</dd>\n\n<dt>afterClose</dt>\n<dd>Если приложение имеет этот метод, то он будет вызван после удаления поля <code class=\"inline\">container</code> из DOM страницы</dd>\n</dl>\n<p>\nКроме этого, приложение может иметь множество различных URL. В таком случае, приложение может продолжить свое выполнение, если оно имеет метод <code class=\"inline\">canStay</code>, и если этот метод возвращает не <code class=\"inline\">false</code>. Например, как видно отсюда - <a href=\"https://github.com/forweb/web/blob/master/assets/js/project/Application.js\" target=\"_blank\">js/project/Application.js</a> приложение под названием <code class=\"inline\">RoutesInfo</code> имеет два URL - 'routes-info' и 'routes-info/:app'. Различаются эти страницы текстом основного содержимого, поэтому нет смысла заново создавать боковое меню. Посмотреть реализацию  <code class=\"inline\">RoutesInfo</code> можно <a href=\"https://github.com/forweb/web/blob/master/assets/js/project/applications/RoutesInfo.js\" target=\"_blank\">здесь</a>, обратить внимание стоит на метод <code class=\"inline\">canStay</code>.\n</p>\n<p class=\"info\">\nИтого, приложение должно иметь поле <code class=\"inline\">container</code>, может иметь методы <code class=\"inline\">beforeOpen</code>, <code class=\"inline\">afterOpen</code>, <code class=\"inline\">beforeClose</code>, <code class=\"inline\">afterClose</code>, <code class=\"inline\">canStay</code> и в случае если приложение это не функция а объект, то оно может иметь метод <code class=\"inline\">init</code>\n</p>",
    "routes_dispatcher_content": "<h1>Dispatcher</h1>\n<p>\nКлючевым классом для управления страницами является класс <code class=\"inline\">Dispatcher</code>. Этот класс отвечает за инстанциацию, запуск, и завершение работы приложения удовлетворяющего текущему URL ресурса.\n</p>\n\n\n\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет конструктор и методы:\n</p>\n<table>\n<tr>\n  <th>Метод</th><th>аргументы</th><th>описание</th>\n</tr>\n\n<tr>\n  <td>Конструктор</td><td>appNode[string|Dom node]<br/>context[object]<br/>config[object|Config]<br/>urlResolver[UrlResolver|null]</td><td>Для создания экземпляра класса нужно вызвать конструктор как минимум с одним параметром <code>appNode</code>. Это может быть строка-идентификатор существующего DOM элемента, либо DOM элемент. Context может быть не передан, тогда вместо него будет создан простой объект. <code>Dispatcher</code> будет хранить в этом элементе состояние запроса - <code>{request: {url: \"current/url\", params: {url: params}}}</code>. Config может быть не передан, тогда вместо него будет создан обычный объект. Рекомендуется передавать сюда экземпляр класса <code>Config</code>. <code>UrlResolver</code> не является обязательным параметром, и его передавать не рекомендуется, поскольку его реализация есть в фреймворке.</td>\n</tr>\n\n\n<tr>\n  <td>addMapping</td><td>className[string]<br/>url[string]</td><td>Этот метод связывает URL ресурса с требуемым приложением. Примеры вызова метода:<br/>\n<code>dispatcher.addMapping('Forum', 'forum')</code><br/>\n<code>dispatcher.addMapping('Topic', 'forum/topic/:id')</code><br/>\nВо втором случае, при URL 'forum/topic/12' приложение <code>Topic</code> сможет использовать <code>context.request.params.id</code>, который будет равен 12.\n</td>\n</tr>\n\n<tr>\n  <td>addListener</td><td>name[string|function]<br/>listener[function|undefined]</td><td>При размещении приложения <code>dispatcher</code> генерирует 4 события - <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>. Первый аргумент должен быть одним из них, а второй аргумент должен быть функцией. Если передан только один аргумент, то это должна быть функция, а названием события в этом случае будет <code>afterOpen</code>.\n</td>\n</tr>\n\n\n<tr>\n  <td>placeApplication</td><td>url[string|null]<br/>directives[mixed]</td><td>Этот метод используется для размещения нового приложения. Если метод не получает параметров, то используется текущий URL ресурса, если передан один параметр, то он будет использован как URL. Если передан второй параметр, то он будет передан в такие методы приложения как beforeOpen и afterOpen.\n</td>\n</tr>\n\n<tr>\n  <td>placeApplication</td><td>eventType[string]<br/>applicationName[string]</td><td>Этот метод триггерит событие, вызывая всех слушателей, которые на него подписаны. Первый аргумент обязателен, и он должен быть одним из <code>[beforeOpen, afterOpen, beforeClose, afterClose]</code>.\n</td>\n</tr>\n\n</table>\n\n<p>\nКласс <code class=\"inline\">Dispatcher</code> имеет следующие поля:\n</p>\n<table>\n<tr>\n  <th>Поле</th><th>Тип</th><th>По умолчанию</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>app</td><td>DOM node</td><td>null</td><td>Это поле хранит DOM node, в которую будет положено активное приложение. Это обязательное поле, которое инстанциируется при создании экземпляра класса. Для его инстанциации первый аргумент конструктора должен быть строкой или DOM node. Если передаваемый параметр строка, то она должна соответствовать идентификатору существующего элемента.</td>\n</tr>\n<tr>\n  <td>context</td><td>object</td><td>{}</td><td>Это поле создано для передачи объектов между приложениями в течении работы системы. Это контекст приложения, в который можно положить что угодно, например какие-то результаты работы приложения, сервисы, результаты ajax-запросов и проч.</td>\n</tr>\n\n<tr>\n  <td>config</td><td>Config</td><td>{}</td><td>Это поле похоже на предыдущее, только с тем отличием, что в нем должны храниться настройки приложения, или какие-то предпочтения пользователя. Желательно хранить здесь простые конструкции типа <code>{string:string}</code>. Лучшим выбором будет использование класса Config, поскольку он использует localStorage для сохранения состояний между сессиями.</td>\n</tr>\n\n<tr>\n  <td>applications</td><td>object</td><td>{}</td><td>Здесь экземпляр класса <code>Dispatcher</code> хранит загруженные приложения. В теории доступ к полю не должен понадобиться, поскольку это поле было создано для внутреннего использования.</td>\n</tr>\n\n<tr>\n  <td>activeApplication</td><td>object</td><td>null</td><td>Это текущее развернутое приложение. О приложениях стоит говорить отдельно.</td>\n</tr>\n\n<tr>\n  <td>history</td><td>BrowserHistory</td><td>BrowserHistory</td><td>Объект истории браузера, используется для навигации и подписки на события о смене URL ресурса. По умолчанию используется история браузера</td>\n</tr>\n\n<tr>\n  <td>urlResolver</td><td>object</td><td>UrlResolver</td><td>Объект с двумя методами - <code>addMapping(appName, url)</code> и <code>resolve(url)</code>. Это поле отвечает за разбор URL и поиск соответствующего приложения. Для его инстанциации нужно передать 4 параметр в конструктор класса <code>Dispatcher</code>, если же четвертый параметр будет пустым, то диспетчер создаст его сам.</td>\n</tr>\n\n<tr>\n  <td>events</td><td>object</td><td>null</td><td><code>Dispatcher</code> может подписать какие-то объекты на 4 события развертки приложения - 'beforeOpen', 'afterOpen', 'beforeClose', 'afterClose'. Поле сделано для внутреннего использования.</td>\n</tr>\n</table>",
    "routes_url_resolver_content": "<h1>Разбор URL ресурса</h1>\n<p><code class=\"inline\">Dispatcher</code> отвечает за развертывание приложений, но для того чтобы понять какое именно приложение должно быть развернуто, он нуждается в экземпляре <code class=\"inline\">UrlResolver</code>. Этот класс не требует инициализации со стороны пользователя, поскольку объект <code class=\"inline\">Dispatcher</code> делает это сам, но, при необходимости, он может быть переопределен. Главная задача этого класса - получить URL ресурса, и сказать какое приложение диспетчер должен развернуть и с какими параметрами. Для этого используются следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Параметры</th><th>Возвращаемое значение</th><th>Описание</th>\n</tr>\n<tr>\n  <td>Конструктор</td>\n  <td>path(string)</td>\n  <td>this</td>\n  <td>Конструктор класса</td>\n</tr>\n<tr>\n  <td>resolve</td>\n  <td>url(string)</td>\n  <td>object{params:object,app:string,url:string}</td>\n  <td>Метод разбирает URL и ищет подходящее приложение. Кроме этого, в процессе поиска приложения, класс создает объект params (если параметры есть). Например, если для приложения <code>Forum</code> используется такой URL \"forum/:topic\", и в метод приходит <code>\"forum/10\"</code>, то объект <code>params</code> будет выглядеть так: <code>{topic:10}</code>.</td>\n</tr>\n<tr>\n  <td>addMapping</td>\n  <td>className(string)<br/>url(string)</td>\n  <td>void|throw exception</td>\n  <td>Метод связывает имя класса и URL. Рабочими URL являются следующие шаблоны <code>\"forum\"</code>, <code>\"forum/:topic\"</code>, <code>\"/forum/:topic/*\"</code>. В последнем случае <code>*</code> будет означать что угодно. Если маппинг уже существует, например, уже есть \"forum/:topic\", и совершается попытка добавить маппинг на \"forum:id\" метод выбросить исключение.</td>\n</tr>\n<tr>\n  <td>parseUrl</td>\n  <td>url(string)</td>\n  <td>[]</td>\n  <td>Метод сделан для внутреннего использования. Возвращает массив объектов, с информацией о каждом сегменте URL. Например для <code>\"forum/:topic\"</code> результатом будет <code>[{name:forum,dynamic:false},{name:topic, dynamic: true}]</code></td>\n</tr>\n\n</table>",
    "utils_info_content": "<h1>Классы - утилиты</h1>\n<p>\nФреймворк содержит набор вспомогательных классов-утилит, которые будут полезны при разработке. Они облегчают работу с DOM-элементами, с ajax-запросами, обработкой событий, изменением адресной строки и при работе со строками. Также, классы-утилиты используются повсеместно в компонентах фреймворка.\n</p>",
    "utils_info_ajax_content": "<h1>Ajax</h1>\n<p>Этот класс сделан как прослойка облегчающая работу с XmlHttpRequest. Реализация класса - простой JS объект, поэтому создание экземпляров не требуется.</p>\n<p class=\"warning\">\nИспользование этого класса не рекомендуется, поскольку в фреймворке есть класс с более удобным API - <code class=\"inline\">Rest</code>.\n</p>\n<p>Класс имеет следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>ajax</td>\n  <td>data(Object)<br>resolve(Function)<br>reject(Function)</td>\n  <td>void</td>\n  <td>Основной метод класса, который совершает отправку данных при помощи XmlHttpRequest. В случае успеха (если статус ответа 200 (если статус ответа между 199 и 300)) вызывается функция <code>resolve</code>, где первым аргументом будет ответ от сервера, вторым будет объект XmlHttpRequest. В другом случае вызывается функция <code>Reject</code>, если она была передана, в которую первым аргументом будет передан объект XmlHttpRequest. Объект <code>data</code> может содержать следующие ключи:type, url, data, headers, responseType. <code>type</code> это обязательный ключ, который означает тип запроса - get, post, put и проч. <code>url</code> это обязательный ключ, который должен быть равен URL запрашиваемого ресурса. <code>data</code> это необязательный ключ, который является строковым представлением отправляемых данных. <code></code>headers это необязательный ключ, который может содержать объект из пар ключ-значение для выставления нужных заголовков запроса. Эти заголовки имеют больший приоритет, нежели заголовки из поля <code>Ajax.headers</code>. <code>responseType</code> это ключ, который означает тип возвращаемых данных. Может быть <code>json</code> или <code>text</code></td>\n</tr>\n\n<tr>\n  <td>process</td>\n  <td>xhr(Object)<br>type(string)</td>\n  <td>String|Object</td>\n  <td>\n     Метод для внутреннего использования. Нужен для того чтобы подготовить ответ от сервера. В случае, если <code>data.responseType</code> был равен <code>text</code> будет возвращено значение xhr.responseText, в ином случае будет возвращен результат <code>JSON.parse(xhr.responseText)</code>.\n  </td>\n</tr>\n\n<tr>\n  <td>getXhr</td>\n  <td></td>\n  <td>object</td>\n  <td>\n    Кроссбраузерное получение объекта XmlHttpRequest\n  </td>\n</tr>\n</table>\n\n\nКласс имеет следующие поля:\n<table>\n<tr>\n<th>Поле</th><th>Тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>headers</td>\n  <td>null|object</td>\n  <td>Этот объект содержит информацию о заголовках, которые будут добавлены во все сущности XmlHttpRequest. Например, если объект будет равен <code>{\"Content-type\", \"application/json\"}</code>, то каждый запрос будет иметь заголовок <code>\"Content-type: application/json\"</code>. Это поле имеет меньший приоритет, нежели объект <code>data.headers</code>, который может быть передан в метод <code>ajax</code>.</td>\n</tr>\n</table>",
    "utils_info_rest_content": "<h1>Rest</h1>\n<p>Этот класс сделан для удобной работы с XmlHttpRequest по типу rest-запросов. Реализация класса - простой JS объект, поэтому создание экземпляров не требуется. Класс использует forweb класс <code class=\"inline\">Ajax</code> для отправки данных, и реализацию Promise для последующей обработки ответа. Класс сделан так, что он может отправлять данные только в формате JSON.</p>\n<p class=\"warning\">\nИспользование класса <code class=\"inline\">Rest</code> в браузерах не поддерживающих технологию Promise невозможно. В таких случаях рекомендуется использовать <a href=\"https://github.com/taylorhakes/promise-polyfill\" target=\"_blank\">Promise Polyfill.</a></p>\n<p>Класс имеет следующие методы:</p>\n<table>\n<tr>\n<th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>doGet</td>\n  <td>url(string)<br>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"get\". Аргумент <code>url</code> это URL запрашиваемого ресурса, а аргумент <code>responseType</code> может быть одним из допустимых типов для класса <code>Ajax</code>.</td>\n</tr>\n\n<tr>\n  <td>doPost</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"post\". Аргумент <code>url</code> это URL запрашиваемого ресурса, аргументом data может быть что угодно, если это не строка или не число, то оно будет преобразовано функцией <code>JSON.stringify</code> а аргумент <code>responseType</code> может быть одним из допустимых типов для класса <code>Ajax</code>.</td>\n</tr>\n\n<tr>\n  <td>doPut</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"put\". В остальном метод идентичен методу <code>doPost</code></td>\n</tr>\n\n<tr>\n  <td>doDelete</td>\n  <td>url(string)<br>data(mixed)<br/>responseType(string)</td>\n  <td>Promise</td>\n  <td>Отправляет запрос с типом \"delete\". В остальном метод идентичен методу <code>doPost</code></td>\n</tr>\n\n</table>\n\n\nКласс имеет следующие поля:\n<table>\n<tr>\n<th>Поле</th><th>Тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>host</td>\n  <td>null|string</td>\n  <td>Это поле сделано для облегчения отправки запросов. Если оно задано, то в начало <code>url</code> каждого запроса будет прибавлено это значение.</td>\n</tr>\n</table>\n\n\n<p>\nПримеры использования:\n</p>\n\n<code>\nRest.host = \"http://my.website.com/\";\n////////////////////////\nRest.doGet(\"users/all\").then(function(users, xhr){\n  console.log(users);\n}, function(xhr){\n  console.log(\"Request fail. Can't load users list\");\n})\n\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doPost(\"users/save\", user).then(function(user, xhr){\n  console.log('user created');\n  console.log(user);\n  console.log(user.id);\n}, function(xhr){\n  console.log(\"Request fail. Can't create user\");\n})\n\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doPut(\"users/save\", user).then(function(user, xhr){\n  console.log('user updated');\n  console.log(user);\n  console.log(user.id);\n}, function(xhr){\n  console.log(\"Request fail. Can't update user\");\n})\n////////////////////////\nvar user = {name: 'Nick', age: 28};\nRest.doDelete(\"users/save\", user.id).then(function(response, xhr){\n  console.log('user deleted');\n}, function(xhr){\n  console.log(\"Request fail. Can't delete user\");\n})\n\n</code>",
    "utils_info_dom_content": "<h1>Dom</h1>\n<p>Класс <code class=\"inline\">Dom</code> помогает взаимодействовать с HTML структурой документа. Основным его предназначением является упрощение создания HTML нод. Кроме этого, он может добавлять и удалять класс из элемента, делать анимацию и упрощает работу с событиями. Класс представляет из себя простой JS объект с набором функций и не требует конфигураций и инстанциации.</p>\n<p class=\"info\">\nОсновная цель класса - создание элементов и работа с ними, а не получение УЖЕ существующих элементов страницы. Все компоненты ForWeb фреймворка выглядят как изолированные независимые модули, и содержат ссылки на все нужные им DOM node. Если в ходе работы вам требуется сделать что-то вроде <code class=\"inline\">document.getElementsByClassName(\".myClass\")</code> это значит что вы делаете что-то не так. Для примера можно посмотреть реализацию компонента <code class=\"inline\">Tabs</code> <a href=\"https://github.com/forweb/core/blob/master/assets/js/org/forweb/components/Tabs.js\">вот по этому адресу</a>\n</p>\n<p>\nКласс имеет следующие функции\n</p>\n<table>\n<tr>\n  <th>Метод</th><th>Аргументы</th><th>возвращаемый тип</th><th>Описание</th>\n</tr>\n<tr>\n  <td>el</td><td>tagName(string)<br/>attributes(string|object)<br/>content(DOM node|string|array)</td><td>DOM node</td>\n  <td>Этот метод создает DOM node. Первый аргумент обязателен, другие нет. Если тип второго аргумента строка, то она будет использована как класс элемента. Третьим аргументом может быть DOM node, или строка. Оба они будут добавлены внутрь содержимого элемента. Если третий аргумент это массив, то элементами массива могут быть DOM node, строки, массивы или их комбинации.</td>\n</tr>\n\n<tr>\n  <td>addClass</td><td>element(DOM node)<br/>className(string)</td><td>void</td>\n  <td>Добавляет класс к выбранному элементу.</td>\n</tr>\n\n<tr>\n  <td>removeClass</td><td>element(DOM node)<br/>className(string)</td><td>void</td>\n  <td>Удаляет класс у выбранного элемента.</td>\n</tr>\n\n<tr>\n  <td>hasClass</td><td>element(DOM node)<br/>className(string)</td><td>boolean</td>\n  <td>Проверяет наличие класса у выбранного элемента</td>\n</tr>\n\n\n<tr>\n  <td>id</td><td>id(string)</td><td>DOM node</td>\n  <td>Возвращает элемент по его идентификатору. В теории, этот метод должен быть вызван только один раз, во время инициализцаии скриптов, для того чтобы получить ссылку на контейнер приложения.</td>\n</tr>\n\n<tr>\n  <td>update</td><td>element(DOM node)<br/>attributes(string|object)</td><td>void</td>\n  <td>Этот метод добавляет атрибуты в переданный элемент. Если тип второго аргумента строка, то она будет использована как класс элемента.</td>\n</tr>\n\n<tr>\n  <td>append</td><td>element(DOM node)<br/>content(DOM node|string|array)</td><td>void</td>\n  <td>Этот метод добавляет содержимое в конец элемента. Вторым аргументом может быть DOM node, или строка. Если третий аргумент это массив, то элементами массива могут быть DOM node, строки, массивы или их комбинации.</td>\n</tr>\n\n<tr>\n  <td>insert</td><td>element(DOM node)<br/>content(DOM node|string|array)<br/>before(DOM node|null)</td><td>void</td>\n  <td>Этот метод добавляет содержимое в начало элемента, или перед третьим аргументом, если он передан. Вторым аргументом может быть DOM node, или строка. Если третий аргумент это массив, то элементами массива могут быть DOM node, строки, массивы или их комбинации.</td>\n</tr>\n\n\n<tr>\n  <td>addListeners</td><td>element(DOM node|object)<br/>listeners(object|null)</td><td>void</td>\n  <td>Добавляет слушателей события к элементу. Вторым аргументом должен быть объект такого вида <code>{onclick:function(){},change:function(){}}</code>. Ключам не обязательно иметь приставку \"on\". Если этот объект передан как первый и единственный аргумент, то слушатели событий будут добавлены в объект <code>window</code></td>\n</tr>\n\n<tr>\n  <td>removeListeners</td><td>element(DOM node|object)<br/>listeners(object|null)</td><td>void</td>\n  <td>Удаляет слушателей событий у элемента. Вторым аргументом должен быть объект такого вида <code>{onclick:function(){},change:function(){}}</code>. Ключам не обязательно иметь приставку \"on\". Если этот объект передан как первый и единственный аргумент, то слушатели событий будут сняты с объекта <code>window</code></td>\n</tr>\n\n<tr>\n  <td>calculateOffset</td><td>element(DOM node)</td><td>object({left:number, top: number})</td>\n  <td>Рассчитывает смещение элемента относительно левого верхнего угла браузера с учетом скрола и отступов родителей. Полезно при работе с различными drag-n-drop'ами</td>\n</tr>\n\n<tr>\n  <td>animate</td><td>el(DOM node)<br/>values(object)<br/>time(number)<br>frame(number)</td><td>object({animate:function, then: function})</td>\n  <td>Плавно изменяет CSS стили элемента. Первый аргумент - целевой DOM элемент, второй аргумент - объект вида <code>{width: 100}</code>, третий аргумент - время в миллисекундах, в течении которого будет происходить анимация, если не передан, то считается равным 3000, четвертый аргумент - время одного \"кадра\" анимации. Этот метод может вызываться цепочкой, которая может (но не должна) заканчиваться методом <code>then</code>, например, <code>Dom.animate(el, {width: 100}).animate(el, width: 50).then(function(){})</code>. Анимации будут вызваны последовательно, новая после окончанию предыдущей, функция-аргумент метода <code>then</code> будет вызвана после окончания последней анимации.</td>\n</tr>\n</table>\n\n<p>\nПримеры использования:\n</p>\n<code>\n//Dom.el\nvar span1 = Dom.el('span');//&lt;span&gt;&lt;/span&gt;\nvar span2 = Dom.el('span', 'clazz');//&lt;span class=\"clazz\"&gt;&lt;/span&gt;\nvar span3 = Dom.el('span', 'clazz', 'content');//&lt;span class=\"clazz\"&gt;content&lt;/span&gt;\nvar span4 = Dom.el('span', {class:'clazz', id: 'my_span'});//&lt;span class=\"clazz\" id=\"my_span\"&gt;&lt;/span&gt;\nvar span5 = Dom.el('span', null, 'content');//&lt;span&gt;content&lt;/span&gt;\nvar span6 = Dom.el('span', null, [span1, span2, span3]);//&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=\"clazz\"&gt;&lt;/span&gt;&lt;span class=\"clazz\"&gt;content&lt;/span&gt;&lt;/span&gt;\n\n//Dom.addClass, Dom.hasClass, Dom.removeClass\nvar elForClasses = Dom.el('span');//&lt;span&gt;&lt;/span&gt;\nDom.addClass(elForClasses, 'foo');//&lt;span class=\"foo\"&gt;&lt;/span&gt;\nDom.addClass(elForClasses, 'bar');//&lt;span class=\"foo bar\"&gt;&lt;/span&gt;\nDom.hasClas(elForClasses, 'foo');//true\nDom.removeClass(elForClasses, 'foo');//&lt;span class=\"bar\"&gt;&lt;/span&gt;\nDom.hasClas(elForClasses, 'foo');//false\n\n//Dom.id; html markup:\n//&lt;div id=\"application\"&gt;&lt;/div&gt;\nvar app = Dom.id('application');\n\n//Dom.update\nvar elForUpdate = Dom.el('span', 'clazz');//&lt;span class=\"clazz\"&gt;&lt;/span&gt;\nDom.update(elForUpdate, {id: 'my_updated_el'});////&lt;span class=\"clazz\" id=\"my_updated_el\"&gt;&lt;/span&gt;\nDom.update(elForUpdate, \"foo\");////&lt;span class=\"foo\" id=\"my_updated_el\"&gt;&lt;/span&gt;\n\n//Dom.append\nvar elForAppend = Dom.el('span');//&lt;span&gt;&lt;/span&gt;\nDom.append(elForAppend, ['content', Dom.el('span', 'clazz')]);//&lt;span&gt;content&lt;span class=\"clazz\"&gt;&lt;/span&gt;&lt;/span&gt;\nDom.append(elForAppend, \"contentAfter\");//&lt;span&gt;content&lt;span class=\"clazz\"&gt;&lt;/span&gt;contentAfter&lt;/span&gt;\n\n//Dom.insert\nvar elForInsert = Dom.el('span', null, 'content');//&lt;span&gt;content&lt;/span&gt;\nDom.insert(elForInsert, ['contentBefore', Dom.el('span', 'clazz')]);//&lt;span&gt;contentBefore&lt;span class=\"clazz\"&gt;&lt;/span&gt;content&lt;/span&gt;\n\n\n//Dom.addListeners, Dom.removeListeners\nvar listeners = {onclick: function(){}, onchange: function(){}, onmouseover: function(){}};\nvar el = Dom.el('span', null, 'content');\nDom.addListeners(el, listeners);\n//need no remove listeners, because GC will remove it when necessary.\n\nvar windowListeners = {onresize: function(){}, onkeypress: function(){}};\nDom.addListeners(windowListeners);\n//it can cause memory leak. So, listeners should be removed:\nDom.removeListeners(windowListeners);\n//Better remove such kind of listeners in 'afterClose' method. More info can be found in routes section, application lifecycle\n\n//Dom.calculateOffset\nvar el = Dom.el('span');\ndocument.body.appendChild(el);\nvar offset = Dom.calculateOffset(el);\nconsole.log(offset)//{left: 0, top: 0};\n\n//Dom.animate:\nvar el = Dom.el('div', null, 'content');\nDom.animate(el, {width: 100});//animate for width 100px during 3 seconds, with step 10 millis\nDom.animate(el, {width: 100}, 5000);//animate for width 100px during 5 seconds, with step 10 millis\nDom.animate(el, {width: 100}, 5000, 4);//animate for width 100px during 5 seconds, with step 4 millis\nDom.animate(el, {width: 100}).//animate for width 100px during 3 seconds, with step 10 millis\n  animate(el, {height: 100}).//animate for height 100px during 3 seconds, with step 10 millis\n  then(function(){el.style.color = \"red\"});//after all animations change element color to red\n</code>",
    "utils_info_config_content": "<h1>Config</h1>\n<p>Этот класс предназначен для хранения данных между сессиями. Хранилищем данных выбран <code class=\"inline\">localStorage</code>. Все данные сохраняются в JSON формате с уникальным идентификатором, который должен быть передан в конструктор класса при его инстанциации.</p>\n<p class=\"warning\">\n  В браузерах не поддерживающих localStorage класс config работать не будет. В таком случае надо использовать какой-нибудь <a href=\"https://gist.github.com/juliocesar/926500\" target=\"_blank\">polyfill</a>.\n</p>\n<p>\n  Класс имеет следующие методы:\n</p>\n<table>\n<tr>\n  <th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>Конструктор</td><td>configName(string)</td><td>Config</td>\n  <td>Создает экземпляр класса Config. Использует configName как ключ, под которым все данные будут хранится в localStorage</td>\n</tr>\n<tr>\n  <td>get</td><td>name(string)</td><td>mixed</td>\n  <td>Возвращает то значение, которое было положено в Config, или undefined</td>\n</tr>\n<tr>\n  <td>has</td><td>name(string)</td><td>boolean</td>\n  <td>Возвращает true в любом случае, кроме тех, когда значение получаемое из Config.get равно undefined</td>\n</tr>\n<tr>\n  <td>set</td><td>name(string)<br>value(mixed)</td><td>void</td>\n  <td>Устанавливает значение в хранилище</td>\n</tr>\n<tr>\n  <td>remove</td><td>name(string)</td><td>void</td>\n  <td>Удаляет значение из хранилища</td>\n</tr>\n</table><p>Пример использования можно посмотреть <a href=\"https://github.com/forweb/web/blob/master/assets/js/project/Application.js\" target=\"_blank\">в конструкторе этого класса</a>. Здесь экземпляр класса Config устанавливается внутрь контекста веб приложения, и становится доступен для всех внутренних приложений.</p>",
    "utils_info_string_utils_content": "<h1>String Utils</h1>\n<p>\nКласс StringUtils представляет из себя простой JS объект с небольшим набором полезных функций для операций над строками. Класс не требует инициализации.\n</p>\n<table>\n  <tr>\n    <th>Метод</th><th>Аргументы</th><th>Возвращаемое значение</th><th>Описание</th>\n  </tr>\n  <tr>\n    <td>unique</td><td>length(int)</td><td>String</td>\n    <td>Генерирует случайную строку. Удобно использовать как генератор идентификаторов. Если в функцию ничего не передано, то будет считаться что длина идентификатора равна 5.</td>\n  </tr>\n\n  <tr>\n    <td>removeSlashes</td><td>str(string)</td><td>String</td>\n    <td>Убирает первый и последний символ \"/\" из строки. Используется при работе с URL либо с путями в файловой системе.</td>\n  </tr>\n\n  <tr>\n    <td>capitalize</td><td>str(string)</td><td>String</td>\n    <td>Выставляет первую букву переданной строки в верхний регистр.</td>\n  </tr>\n\n  <tr>\n    <td>normalizeText</td><td>str(string)<br/>glue(string)</td><td>String</td>\n    <td>Превращает строку в читаемый текст. Например, <code>camelCasedText</code> будет превращено в <code>Camel Cased Text</code>. Точно также работает со строками разделеными символами \"_\" и \"-\". Если задан второй параметр, то текст будет соединен вторым параметром. Тоесть, для вызова <code>StringUtils.normalizeText(\"someText\", \"__\")</code> результат будет <code>Some__Text</code></code></td>\n  </tr>\n\n</table>",
    "utils_info_url_utils_content": "<h1>UrlUtils</h1>\n<p>\nUrlUtils это класс представленный простым JS объектом без состояния. Он содержит несколько методов, которые помогают управлять текущим URL, особенно query частью (которая идет после знака \"?\").\n</p>\n<table>\n<tbody><tr>\n  <th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>getPath</td><td>param(int)</td><td>String</td>\n  <td>Возвращает path текущего URL без начального и конечных символов \"/\". Если передан первый аргумент, то будет возвращен сегмент path. Например, для URL <code>http://site.com/forum/programming/topic_1</code> код <code>UrlUtils.getPath()</code> вернет <code>forum/programming/topic_1</code>, в то время как метод <code>UrlUtils.getPath(1)</code>  вернет <code>forum</code>. Нумерация начинается с 1. \n\n<p class=\"warning\">В контексте ForWeb фреймворка этим методом пользоваться не рекомендуется, поскольку данные о состоянии URL приложение получит при инициализации. Читай раздел \"Маршрутизация\" о приложениях и контексте.</p></td>\n</tr>\n\n\n<tr>\n  <td>getQuery</td><td>paramName</td><td>string</td>\n  <td>Возвращает параметр запроса. Например, вызов метода <code>UrlUtils.getQuery('topic')</code> для URL <code>http://site.com?app=forum&amp;topic=programming&amp;thread=topic_1</code> вернет значение \"programming\"</td>\n</tr>\n\n<tr>\n  <td>appendQuery</td><td>name(string)<br>value(string)</td><td>void</td>\n  <td>Добавляет параметр запроса в текущий URL</td>\n</tr>\n\n<tr>\n  <td>removeQuery</td><td>name</td><td>void</td>\n  <td>Удаляет параметр запроса из текущего URL</td>\n</tr>\n\n</tbody></table>",
    "utils_info_screen_utils_content": "<h1>ScreenUtils</h1>\n<p>\nScreenUtils это класс представленный простым JS объектом без состояния. Он содержит несколько методов, которые помогают получить данные о размере активного окна и монитора.\n</p>\n<table>\n<tbody><tr>\n  <th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n</tr>\n\n<tr>\n  <td>window</td><td></td><td>object({width: int, height: int})</td>\n  <td>Получает размеры окна</td>\n</tr>\n<tr>\n  <td>monitor</td><td></td><td>object({width: int, height: int})</td>\n  <td>Получает размеры монитора пользователя</td>\n</tr>\n\n</tbody></table>",
    "forms_info_content": "<h1>Формы</h1>\n<p>\nФреймворк ForWeb содержит пакет с классами форм и их компонент. В пакет входят базовые элементы, такие как текстовое поле, чекбокс, радиокнопка, выпадающий список, правила для валидации и особый класс <code class=\"inline\">GenericForm</code> который позволит использовать все компоненты в связке, и даже сможет построить готовую форму по модели данных. В случае, когда форма действительно сложная, и не может быть сгенерирована автоматически опираясь на модель данных, на помощь придет класс <code class=\"inline\">FieldMeta</code>, который содержит в себе необходимые поля для особого отображения информации.\n</p>",
    "forms_abstract_input_content": "<h1>AbstractInput</h1>\n    <p>\n        Этот абстрактный класс является родителем для всех компонентов форм. Класс имеет следующие абстрактные методы:\n    </p>\n    <table>\n        <tr>\n            <th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n        </tr>\n\n        <tr>\n            <td>getInputType</td><td></td><td>String</td>\n            <td>Получает тип будущего поля. Тип должен быть совместим с атрибутом <code>type</code> для тега <code>&lt;input/&gt;</code>. Метод обязателен к реализации, пусть даже возвращаемым значением будет null (например компоненты <a href=\"https://github.com/forweb/core/blob/master/assets/js/org/forweb/form/Textarea.js\" target=\"_blank\">Textarea</a> и <a href=\"https://github.com/forweb/core/blob/master/assets/js/org/forweb/form/Select.js\" target=\"_blank\">Select</a>)</td>\n        </tr>\n\n        <tr>\n            <td>getElementType</td><td></td><td>String</td>\n            <td>Получает имя тега будущего поля (\"input\", \"select\", \"textarea\"). Метод обязателен к реализации.</td>\n        </tr>\n\n    </table>\n    <p>\n        Класс реализует следующие методы:\n    </p>\n    <table>\n        <tr>\n            <th>Метод</th><th>Аргументы</th><th>Возвращаемый тип</th><th>Описание</th>\n        </tr>\n\n\n        <tr>\n            <td>Конструктор класса</td><td>params(object)</td><td>Экземпляр класса</td>\n            <td>Конструктор получает один единственный аргумент - params. Этот объект может содержать следующие поля:\n                <p class=\"info\">\n                    <b>name(string)</b> - обязательное поле, определяет имя создаваемого элемента.<br/>\n                    <b>value(mixed)</b> - определяет значение по умолчанию для создаваемого элемента. Работает одинаково для всех компонент, включая Checkbox и Radio<br/>\n                    <b>class(string)</b> - создает имя класса для компоненты. Это поле пишется в самый верхний контейнер компоненты<br/>\n                    <b>id(string)</b> - создает идентификатор элемента. Пишется в рабочий элемент (input, textarea или select), если не указан, то генерируется на лету.<br/>\n                    <b>options(array)</b> - массив объектов вида \"{value: string|int|boolean, label:string|DOM node}\". Необходим для Radio, Select компонентов<br/>\n                    <b>formId(string)</b> - идентификатор формы в которой компонент будет использоваться. Если указан, то будет использован в генерации идентификатора компоненты.<br/>\n                    <b>label(string|DOM node)</b> - отображаемое имя элемента. Если не указано, то будет сгенерировано автоматически исходя из поля name.<br/>\n                    <b>noLabel(boolean)</b> - если задано как \"true\", то отображаемое название компонента генерироваться не будет.<br/>\n                    <b>attr(object)</b> - если задано, то все ключи и значения будут развернуты как атрибуты активного элемента. Если значение указано как функция, то будет создан слушатель событий.\n                </p></td>\n        </tr>\n\n\n        <tr>\n            <td>getValue</td><td></td><td>mixed</td>\n            <td>Основной метод компоненты, получает ее текущее значение</td>\n        </tr>\n\n        <tr>\n            <td>setValue</td><td>value(mixed)</td><td>void</td>\n            <td>Основной метод компоненты, устанавливает значение</td>\n        </tr>\n\n        <tr>\n            <td>prepareAttributes</td><td>params(object)</td><td>object</td>\n            <td>Метод подготавливает набор атрибут для создания активного элемента (input, textarea, select). Это должен быть объект, который принимает функция <code>Dom.el()</code> вторым аргументом.</td>\n        </tr>\n\n\n        <tr>\n            <td>prepareContent</td><td>params(object)</td><td>object</td>\n            <td>Метод подготавливает внутреннее содержимое компонента (innerHTML). Результатом должно быть что-то, что принимает функция <code>Dom.el()</code> третьим аргументом.</td>\n        </tr>\n\n\n        <tr>\n            <td>buildLabel</td><td>params(object)</td><td>DOM node</td>\n            <td>Метод создает отображаемое имя для активного элемента (label)</td>\n        </tr>\n\n        <tr>\n            <td>addError</td><td>errors(object|string)</td><td>object</td>\n            <td>Добавляет (и отображает) ошибку. Входной параметр должен быть объект вида <code>{reqiured: \"Value is required\", length: \"Value must be between 5 and 20 characters\"}</code>. Если входной параметр строка, то он будет преобразован в объект вида <code>{custom: \"Here is your message\"}</code>. Ключи возвращаемого объекта - имена ошибок, значения - html элементы.</td>\n        </tr>\n\n        <tr>\n            <td>removeErrors</td><td>errors(array|string)</td><td>void</td>\n            <td>Удаляет сообщения об ошибке. Если ничего не передано, то будут удалены все сообщения. Если передан массив строк с именами ключей ошибок, то будут удалены только выбранные. Если передана строка, то она будет превращена в массив из одного элемента.</td>\n        </tr>\n    </table>\n    <p>\n        Класс имеет следующие поля\n    </p>\n    <table>\n        <tr>\n            <th>Поле</th><th>Тип</th><th>Описание</th>\n        </tr>\n        <tr>\n            <td>container</td><td>DOM node</td>\n            <td>Верхний контейнер компоненты. Вся HTML структура компоненты находится в этом поле</td>\n        </tr>\n        <tr>\n            <td>input</td><td>DOM node</td>\n            <td>Активный элемент компоненты (select, textarea или input)</td>\n        </tr>\n        <tr>\n            <td>label</td><td>DOM node</td>\n            <td>Отображаемое наименование DOM элемента</td>\n        </tr>\n        <tr>\n            <td>errors</td><td>DOM node</td>\n            <td>Все ошибки (если они есть) будут хранится внутри этого поля</td>\n        </tr>\n        <tr>\n            <td>errorsData</td><td>object</td>\n            <td>Данные об ошибках в формате <code>{reqiured: \"Value is required\", length: \"Value must be between 5 and 20 characters\"}</code></td>\n        </tr>\n\n    </table>",
    "forms_text_content": "<h1>Text</h1>\n<p>\nЭтот класс сделан для отображения текстового поля. Все методы и поля такие же как в <code class=\"inline\">AbstractInput</code>\n</p>",
    "forms_textarea_content": "<h1>Textarea</h1>\n<p>\nЭтот класс сделан для отображения многострочного текстового поля. Все методы и поля такие же как в <code class=\"inline\">AbstractInput</code>\n</p>",
    "forms_checkbox_content": "<h1>Checkbox</h1>\n<p>\nЭтот класс сделан для отображения чекбокса. Все методы и поля такие же как в <code class=\"inline\">AbstractInput</code>\n</p>",
    "forms_radio_content": "<h1>Radio</h1>\n<p>\nЭтот класс сделан для отображения радиокнопки. Все методы и поля такие же как в <code class=\"inline\">AbstractInput</code>\n</p>",
    "forms_select_content": "<h1>Select</h1>\n<p>\nЭтот класс сделан для отображения выпадающего списка. Все методы и поля такие же как в <code class=\"inline\">AbstractInput</code>\n</p>",
    "forms_validation_content": "<h1>Validation</h1>\n<p>Этот класс отвечает за валидацию форм. Содержит только один метод <code class=\"inline\">validate</code>, и несколько\n    полей с дефолтными сообщениями о ошибках и правилах валидации. Класс представлен простым JS объектом, и не требует\n    инициализации. </p>\n<p class=\"info\">\n    <code class=\"inline\">Validation</code> можно использовать самостоятельно, но лучше этого не делать, поскольку он\n    используется внутри класса <code class=\"inline\">GenericForm</code>.\n\n</p>\n<table>\n    <tr>\n        <th>Метод</th>\n        <th>Аргументы</th>\n        <th>Возвращаемое значение</th>\n        <th>Описание</th>\n    </tr>\n    <tr>\n        <td>validate</td>\n        <td>value(mixed)<br/>rules(string|object)</td>\n        <td>errors</td>\n        <td>Метод проверяет, удовлетворяет ли переданное значение переданным условиям. Значение может быть любым, а\n            условия\n            должны иметь определенный формат. Самым правильным будет такой - <code>{required: [true], length: [3,\n                20]}</code>. Ключами этого объекта будут правила валидации, массив значений для каждого ключа это\n            аргументы,\n            которые получит валидационная функция, то есть функция <code>Validation.rules.length</code> получит три\n            аргумента - первым всегда будет проверяемое значение, вторым будет \"3\" и третьим будет \"20\". Для более\n            краткой\n            записи можно использовать <code>{required: 1, length: [3, 20]}</code>. Кроме этого, вместо объекта можно\n            передавать строку - <code>\"required length:3:20\"</code>. Возвращаемым значением будет массив, содержащий\n            ключи\n            ошибок, которые не прошли правила валидации (в данном случае это может быть <code>['required',\n                'length']</code>.\n            В случае успешной валидации, этот массив будет пустым.\n        </td>\n    </tr>\n</table>\n\n<p>\n    Класс содержит поле <code class=\"inline\">rules</code>, в котором хранятся все валидационные правила. Эти правила\n    могут быть переопределены или дополнены. Методы поля <code class=\"inline\">Validation.rules</code>:\n</p>\n\n<table>\n    <tr>\n        <th>Метод</th>\n        <th>Аргументы</th>\n        <th>Возвращаемое значение</th>\n        <th>Описание</th>\n    </tr>\n\n    <tr>\n        <td>required</td>\n        <td>value(mixed)<br/>flag(string)</td>\n        <td>boolean</td>\n        <td>Приводит значение к булевому типу и возвращает его. Если второй параметр равен <code>lazy</code>, то вернет\n            <code>false</code> в случае если значение равно строковому нолю (<code>\"0\"</code>) или если значение\n            становится\n            пустой строкой после применения метода <code>trim()</code>. Если второй аргумент равен значению\n            <code>checkboxes</code>, то проверяемое значение должно быть объектом вида <code>{male: true, female: false}</code>.\n        </td>\n    </tr>\n\n    <tr>\n        <td>max</td>\n        <td>value(mixed)<br/>limit(int)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли число меньше чем второй аргумент. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>min</td>\n        <td>value(mixed)<br/>limit</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли число меньше чем второй аргумент. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>length</td>\n        <td>value(mixed)<br/>min(int)<br/>max(int)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли длинна строки больше второго параметра и меньше третьего. В случае если в функцию\n            придет\n            <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>pattern</td>\n        <td>value(mixed)<br/>pattern(regexp)</td>\n        <td>boolean</td>\n        <td>Проверяет, удовлетворяет ли строка переданному регулярному выражению\n        </td>\n    </tr>\n\n    <tr>\n        <td>number</td>\n        <td>value(mixed)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли переданная строка числом. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>positive</td>\n        <td>value(mixed)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли переданная строка позитивным числом. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>negative</td>\n        <td>value(mixed)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли переданная строка негативным числом. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n        </td>\n    </tr>\n\n    <tr>\n        <td>email</td>\n        <td>value(mixed)</td>\n        <td>boolean</td>\n        <td>Проверяет, является ли переданная строка email адресом. В случае если в функцию придет <code>null, undefined, \"\", false</code> будет возвращено <code>true</code>\n            <p class=\"warning\">\n                Единственный верный способ проверить правильность email - отправить туда письмо.\n            </p>\n        </td>\n    </tr>\n\n    <tr>\n        <td>time</td>\n        <td>value(mixed)</td>\n        <td>boolean</td>\n        <td>Проверяет, подходит ли строка под шаблон <code>hh:mm:ss</code></td>\n    </tr>\n\n    <tr>\n        <td>custom</td>\n        <td>value(mixed)<br/>clb(function)</td>\n        <td>boolean</td>\n        <td>Вызывает второй аргумент и передает туда проверяемое значение. Возвращает полученный результат.</td>\n    </tr>\n</table>",
    "forms_field_meta_content": "<h1>FieldMeta</h1>\n<p>\nКласс <code class=\"inline\">GenericForm</code> создает HTML форму исходя из объекта с данными. Такая форма будет содержать только текстовые поля и <td></td>чекбоксы, если данные имеют тип boolean. Класс <code class=\"inline\">FieldMeta</code> несет в себе дополнительную информацию для кастомизации формы. При помощи <code class=\"inline\">FieldMeta</code> можно создать практически любую форму написав минимум кода.\n</p>\n<p class=\"info\">\nЭтот класс не является обязательным. Это класс-справочник, заглянув в код которого можно без труда понять какие именно поля должны быть заданы для <code class=\"inline\">GenericForm</code>. Вместо создания экземпляров класса <code class=\"inline\">FieldMeta</code> можно создавать простые JS объекты с такими же полями.\n</p>\n<table>\n<tr>\n  <th>Поле</th><th>Тип</th><th>Дефолтное значение</th><th>Описание</th>\n</tr>\n\n\n<tr>\n  <td>ignore</td><td>boolean</td><td>false</td>\n  <td>Если это поле равно \"true\", то поле ввода не будет создано.</td>\n</tr>\n\n<tr>\n  <td>render</td><td>function</td><td>null</td>\n  <td>Если эта функция указана, то она должна вернуть экземпляр <code>AbstractInput</code></td>\n</tr>  <tr>\n  <td>wrapper</td><td>DOM node|function</td><td>null</td>\n  <td>Если указано, то при создании формы поле ввода будет помещено внутрь этого элемента. Если вместо DOM node передана функция, то она получит полем ввода как первый аргумент</td>\n</tr>\n\n<tr>\n  <td>contentBefore</td><td>DOM node|string|array</td><td>null</td>\n  <td>Помещает данное содержимое перед полем ввода</td>\n</tr>\n\n<tr>\n  <td>contentAfter</td><td>DOM node|string|array</td><td>null</td>\n  <td>Помещает данное содержимое после поля ввода</td>\n</tr>\n\n<tr>\n  <td>validations</td><td>string|object</td><td>null</td>\n  <td>Правила валидации для поля</td>\n</tr>\n<tr>\n  <td>listeners</td><td>object|function</td><td>null</td>\n  <td>Значением поля должен быть объект, ключами которого являются названия событий, а значениями функции, которые будут эти события обрабатывать. Если вместо объекта передана функция, то она будет слушать событие <code>onchange</code></td>\n</tr>\n\n<tr>\n  <td>removeErrors</td><td>function</td><td>null</td>\n  <td>Если задано, то в случае, когда у поля ввода надо убрать сообщения об ошибках будет вызвана эта функция. Если она указана, то логика скрытия ошибок ложится на пользователя.</td>\n</tr>\n\n<tr>\n  <td>errorMessages</td><td>object</td><td>null</td>\n  <td>объект в котором ключи соответствуют именам ошибок, а значения являются сообщениями об ошибках</td>\n</tr>\n\n<tr>\n  <td>options</td><td>array</td><td>null</td>\n  <td>Обязательное поле для полей ввода с типом \"select\", \"radio\", \"checkboxes\". Значениями должны быть объекты вида <code>{value: mixed, label: string}</code>. Если не задано поле type, и количество опций не превышает 3, то будет создана радиокнопка. Если опций больше, то будет создан выпадающий список</td>\n</tr>\n\n<tr>\n  <td>type</td><td>string</td><td>null</td>\n  <td>Определяет тип будущего поля ввода. Не сработает если задано поле render.</td>\n</tr>\n\n<tr>\n  <td>label</td><td>string|DOM node|array</td><td>null</td>\n  <td>Устанавливает надпись для элемента. Если не задан, то будет построен исходя из имени поля</td>\n</tr>\n\n<tr>\n  <td>wordKey</td><td>string</td><td>null</td>\n  <td>Поле для интеграции с модулем <code>Word</code>. Используется для интернационализации подписи элемента.\n<p class=\"info\">Для того чтобы это поле могло работать, в конструктор <code>GenericForm</code> нужно в третьем параметре передать поле <code>wordKey</code>, которое будет означать раздел из переводов. Детальнее смотри <code>Word.create</code> и конструктор <code>GenericForm</code></p></td>\n</tr>\n\n<tr>\n  <td>wordErrorKey</td><td>string|object</td><td>null</td>\n  <td>Поле для интеграции с модулем <code>Word</code>. Используется для интернационализации ошибок элемента. Если параметр строка, то у поля должно быть только одно правило для валидации, иначе все сообщения об ошибках будут одинаковы. Если параметр объект, то ключами должны быть имена ошибок (валидаций), а значениями ключи из соответствующего раздела модуля переводов.\n<p class=\"info\">Для того чтобы это поле могло работать, в конструктор <code>GenericForm</code> нужно в третьем параметре передать поле <code>wordKey</code>, которое будет означать раздел из переводов. Детальнее смотри <code>Word.create</code> и конструктор <code>GenericForm</code></td>\n</tr>\n</table>\n\n<p>\nПримеры использования смотри в <code class=\"inline\">GenericForm</code>\n</p>",
    "forms_generic_form_content": "<h1>GenericForms</h1>\n<p>\nЭтот класс был создан для отображения форм с написанием минимального количества кода. Для создания простейшей формы достаточно передать в конструктор класса модель данных и обработчик сабмита формы, и весь необходимый HTML будет помещен внурть поля container. Для создания более сложной формы нужно передать объект с метаданными для полей. Класс имеет следующие методы:\n</p>\n<table>\n<tr>\n  <td>Метод</td><td>Аргументы</td><td>Возвращаемый тип</td>\n  <td>Описание</td>\n</tr>\n<tr>\n  <td>Конструктор</td><td>data(object), fieldsMeta(object), formMeta(object|function)</td><td>Экземпляр класса</td>\n  <td>Объект data это модель данных. Этот аргумент очень важен, поскольку форма будет сформирована основываясь именно на этом объекте. Значениями полей может быть что угодно, включая <code>undefined</code>, главное чтобы в объекте были ключи. Также обязательным является последний (третий) параметр. Если в функцию передано только два параметра, то считается что второй параметр равен <code>null</code> а третьему параметру будет присвоено значение второго. Последним параметром может быть функция, которая будет обрабатывать сабмит формы, либо это может быть объект с обязательным полем <code>onSubmit</code>. Второй (необязательный) параметр это простой JS объект, ключами которого должны быть экземпляры класса <code>FieldMeta</code> или объекты с такими же полями. Если третий параметр это объект, то он может содержать ключ <code>wordKey</code>. Если этот ключ задан, то форма интегрируется с модулем <code>Word</code> и берет названия подписей и ошибок из модуля переводов. Также этот объект может содержать поле <code>submitButton</code>. Если это поле будет равно <code>false</code> то кнопка submit не будет добавлена в форму, если это поле будет иметь тип DOM node, то оно будет использоваться вместо кнопки сабмита по умолчанию. Вся остальная магия связана исключительно с полями <code>FieldMeta</code>, примеры их использования можно увидеть ниже.</td>\n</tr>\n\n<tr>\n  <td>onSubmit</td><td>event(browser event)</td><td>void</td>\n  <td>Этот метод выполняет валидацию данных, и если она успешна, то он вызывает пользовательский обработчик сабмита, который должен был быть передан третьим аргументом в конструктор класса.</td>\n</tr>\n\n\n\n</table>"
  },
  "sample_generic_form": {
    "label_firstName": "Имя",
    "last_name": "Фамилия",
    "label_smoker": "Курильщик",
    "error_firstName": "Поле обязательно к заполнению",
    "error_last_name_required": "Поле 'Фамилия' обязательно к заполнению",
    "error_last_name_length": "Поле 'Фамилия' может должно содержать от 3 до 20 символов"
  }
}
